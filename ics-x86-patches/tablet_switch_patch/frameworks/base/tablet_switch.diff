diff --git a/core/java/android/view/WindowManagerPolicy.java b/core/java/android/view/WindowManagerPolicy.java
index 924cb53..9e2f3a8 100644
--- a/core/java/android/view/WindowManagerPolicy.java
+++ b/core/java/android/view/WindowManagerPolicy.java
@@ -843,6 +843,13 @@ public interface WindowManagerPolicy {
     public void notifyLidSwitchChanged(long whenNanos, boolean lidOpen);
     
     /**
+     * Tell the policy that the lid switch has changed state.
+     * @param whenNanos The time when the change occurred in uptime nanoseconds.
+     * @param lidOpen True if the lid is now open.
+     */
+    public void notifyConvertibleSwitchChanged(long whenNanos, boolean lidOpen);
+    
+    /**
      * Tell the policy if anyone is requesting that keyguard not come on.
      *
      * @param enabled Whether keyguard can be on or not.  does not actually
diff --git a/core/res/res/values/config.xml b/core/res/res/values/config.xml
index 30002c5..aa2ebba 100755
--- a/core/res/res/values/config.xml
+++ b/core/res/res/values/config.xml
@@ -34,6 +34,7 @@
        <item><xliff:g id="id">mute</xliff:g></item>
        <item><xliff:g id="id">volume</xliff:g></item>
        <item><xliff:g id="id">wifi</xliff:g></item>
+       <item><xliff:g id="id">ethernet</xliff:g></item>
        <item><xliff:g id="id">cdma_eri</xliff:g></item>
        <item><xliff:g id="id">data_connection</xliff:g></item>
        <item><xliff:g id="id">phone_evdo_signal</xliff:g></item>
@@ -109,11 +110,12 @@
          does not require auto-restore. -->
     <!-- the 6th element indicates boot-time dependency-met value. -->
     <string-array translatable="false" name="networkAttributes">
-        <item>"wifi,1,1,1,-1,true"</item>
+        <item>"WIFI,1,1,1,-1,true"</item>
         <item>"mobile,0,0,0,-1,true"</item>
         <item>"mobile_mms,2,0,2,60000,true"</item>
         <item>"mobile_supl,3,0,2,60000,true"</item>
         <item>"mobile_hipri,5,0,3,60000,true"</item>
+        <item>"ethernet,9,9,1,-1,ture"</item>
         <item>"mobile_fota,10,0,2,60000,true"</item>
         <item>"mobile_ims,11,0,2,60000,true"</item>
         <item>"mobile_cbs,12,0,2,60000,true"</item>
@@ -136,6 +138,7 @@
     <string-array translatable="false" name="radioAttributes">
         <item>"1,1"</item>
         <item>"0,1"</item>
+        <item>"9,1"</item>
     </string-array>
 
     <!-- Set of NetworkInfo.getType() that reflect data usage. -->
@@ -289,9 +292,20 @@
          app requesting portrait will cause a counter-clockwise rotation.  Setting
          true here reverses that logic. -->
     <bool name="config_reverseDefaultRotation">false</bool>
+    
+    <!-- Influece mode from lid state to rotation 0 means no influence
+         1 means influece if lid closed 2 means influece if lid open. -->
+    <integer name="config_lidInfluecesRotation">0</integer>
 
     <!-- The number of degrees to rotate the display when the keyboard is open. -->
     <integer name="config_lidOpenRotation">90</integer>
+    
+    <!-- Influece mode from convertible state to rotation 0 means no influence
+         1 means influece if convertible closed 2 means influece if convertible open. -->
+    <integer name="config_convertibleInfluecesRotation">0</integer>
+
+    <!-- The number of degrees to rotate the display depending on convertible state see above. -->
+    <integer name="config_convertibleRotation">0</integer>
 
     <!-- The number of degrees to rotate the display when the device is in a desk dock.
          A value of -1 means no change in orientation by default. -->
@@ -328,6 +342,12 @@
          when the lid is open, 2 means it is accessible when the lid is
          closed.  The default is 1. -->
     <integer name="config_lidKeyboardAccessibility">1</integer>
+    
+    <!-- Indicate whether the convertible state impacts the accessibility of
+         the physical keyboard.  0 means it doesn't, 1 means it is accessible
+         when the convertible is open, switch means it is accessible when the convertible is
+         closed.  The default is 1. -->
+    <integer name="config_convertibleKeyboardAccessibility">0</integer>
 
     <!-- Indicate whether the lid state impacts the accessibility of
          the physical keyboard.  0 means it doesn't, 1 means it is accessible
diff --git a/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java b/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java
index 0b223c1..c057f11 100755
--- a/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java
+++ b/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java
@@ -144,11 +144,10 @@ import java.io.PrintWriter;
 import java.util.ArrayList;
 
 /**
- * WindowManagerPolicy implementation for the Android phone UI.  This
- * introduces a new method suffix, Lp, for an internal lock of the
- * PhoneWindowManager.  This is used to protect some internal state, and
- * can be acquired with either thw Lw and Li lock held, so has the restrictions
- * of both of those when held.
+ * WindowManagerPolicy implementation for the Android phone UI. This introduces
+ * a new method suffix, Lp, for an internal lock of the PhoneWindowManager. This
+ * is used to protect some internal state, and can be acquired with either thw
+ * Lw and Li lock held, so has the restrictions of both of those when held.
  */
 public class PhoneWindowManager implements WindowManagerPolicy {
     static final String TAG = "WindowManager";
@@ -159,7 +158,8 @@ public class PhoneWindowManager implements WindowManagerPolicy {
     static final boolean SHOW_STARTING_ANIMATIONS = true;
     static final boolean SHOW_PROCESSES_ON_ALT_MENU = false;
 
-    // Whether to allow dock apps with METADATA_DOCK_HOME to temporarily take over the Home key.
+    // Whether to allow dock apps with METADATA_DOCK_HOME to temporarily take
+    // over the Home key.
     // No longer recommended for desk docks; still useful in car docks.
     static final boolean ENABLE_CAR_DOCK_HOME_CAPTURE = true;
     static final boolean ENABLE_DESK_DOCK_HOME_CAPTURE = false;
@@ -182,7 +182,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
     static final int SYSTEM_DIALOG_LAYER = 5;
     // toasts and the plugged-in battery thing
     static final int TOAST_LAYER = 6;
-    // SIM errors and unlock.  Not sure if this really should be in a high layer.
+    // SIM errors and unlock. Not sure if this really should be in a high layer.
     static final int PRIORITY_PHONE_LAYER = 7;
     // like the ANR / app crashed dialogs
     static final int SYSTEM_ALERT_LAYER = 8;
@@ -200,7 +200,8 @@ public class PhoneWindowManager implements WindowManagerPolicy {
     // the on-screen volume indicator and controller shown when the user
     // changes the device volume
     static final int VOLUME_OVERLAY_LAYER = 16;
-    // things in here CAN NOT take focus, but are shown on top of everything else.
+    // things in here CAN NOT take focus, but are shown on top of everything
+    // else.
     static final int SYSTEM_OVERLAY_LAYER = 17;
     // the navigation bar, if available, shows atop most things
     static final int NAVIGATION_BAR_LAYER = 18;
@@ -219,7 +220,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
     static final int APPLICATION_MEDIA_OVERLAY_SUBLAYER = -1;
     static final int APPLICATION_PANEL_SUBLAYER = 1;
     static final int APPLICATION_SUB_PANEL_SUBLAYER = 2;
-    
+
     static public final String SYSTEM_DIALOG_REASON_KEY = "reason";
     static public final String SYSTEM_DIALOG_REASON_GLOBAL_ACTIONS = "globalactions";
     static public final String SYSTEM_DIALOG_REASON_RECENT_APPS = "recentapps";
@@ -227,13 +228,15 @@ public class PhoneWindowManager implements WindowManagerPolicy {
 
     // Useful scan codes.
     private static final int SW_LID = 0x00;
+    private static final int SW_TABLET_MODE = 0x01;
     private static final int BTN_MOUSE = 0x110;
 
-    /* Table of Application Launch keys.  Maps from key codes to intent categories.
-     *
-     * These are special keys that are used to launch particular kinds of applications,
-     * such as a web browser.  HID defines nearly a hundred of them in the Consumer (0x0C)
-     * usage page.  We don't support quite that many yet...
+    /*
+     * Table of Application Launch keys. Maps from key codes to intent
+     * categories. These are special keys that are used to launch particular
+     * kinds of applications, such as a web browser. HID defines nearly a
+     * hundred of them in the Consumer (0x0C) usage page. We don't support quite
+     * that many yet...
      */
     static SparseArray<String> sApplicationLaunchKeyCategories;
     static {
@@ -253,9 +256,9 @@ public class PhoneWindowManager implements WindowManagerPolicy {
     }
 
     /**
-     * Lock protecting internal state.  Must not call out into window
-     * manager with lock held.  (This lock will be acquired in places
-     * where the window manager is calling in with its own lock held.)
+     * Lock protecting internal state. Must not call out into window manager
+     * with lock held. (This lock will be acquired in places where the window
+     * manager is calling in with its own lock held.)
      */
     final Object mLock = new Object();
 
@@ -268,22 +271,24 @@ public class PhoneWindowManager implements WindowManagerPolicy {
 
     // Vibrator pattern for haptic feedback of a long press.
     long[] mLongPressVibePattern;
-    
+
     // Vibrator pattern for haptic feedback of virtual key press.
     long[] mVirtualKeyVibePattern;
-    
+
     // Vibrator pattern for a short vibration.
     long[] mKeyboardTapVibePattern;
 
-    // Vibrator pattern for haptic feedback during boot when safe mode is disabled.
+    // Vibrator pattern for haptic feedback during boot when safe mode is
+    // disabled.
     long[] mSafeModeDisabledVibePattern;
-    
-    // Vibrator pattern for haptic feedback during boot when safe mode is enabled.
+
+    // Vibrator pattern for haptic feedback during boot when safe mode is
+    // enabled.
     long[] mSafeModeEnabledVibePattern;
 
     /** If true, hitting shift & menu will broadcast Intent.ACTION_BUG_REPORT */
     boolean mEnableShiftMenuBugReports = false;
-    
+
     boolean mSafeMode;
     WindowState mStatusBar = null;
     boolean mStatusBarCanHide;
@@ -296,7 +301,8 @@ public class PhoneWindowManager implements WindowManagerPolicy {
     WindowState mKeyguard = null;
     KeyguardViewMediator mKeyguardMediator;
     GlobalActions mGlobalActions;
-    volatile boolean mPowerKeyHandled; // accessed from input reader and handler thread
+    volatile boolean mPowerKeyHandled; // accessed from input reader and handler
+                                       // thread
     boolean mPendingPowerKeyUpCanceled;
     Handler mHandler;
 
@@ -313,12 +319,23 @@ public class PhoneWindowManager implements WindowManagerPolicy {
 
     int mLidOpen = LID_ABSENT;
 
+    private static final int CONVERTIBLE_ABSENT = -1;
+    private static final int CONVERTIBLE_CLOSED = 0;
+    private static final int CONVERTIBLE_OPEN = 1;
+
+    int mConvertible = CONVERTIBLE_ABSENT;
+
     boolean mSystemReady;
     boolean mSystemBooted;
     boolean mHdmiPlugged;
     int mUiMode = Configuration.UI_MODE_TYPE_NORMAL;
     int mDockMode = Intent.EXTRA_DOCK_STATE_UNDOCKED;
     int mLidOpenRotation;
+    int mLidInflueceRotation;
+
+    int mConvertibleRotation;
+    int mConvertibleInflueceRotation;
+
     int mCarDockRotation;
     int mDeskDockRotation;
     int mHdmiRotation;
@@ -330,6 +347,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
     boolean mCarDockEnablesAccelerometer;
     boolean mDeskDockEnablesAccelerometer;
     int mLidKeyboardAccessibility;
+    int mConvertibleKeyboardAccessibility;
     int mLidNavigationAccessibility;
     int mLongPressOnPowerBehavior = -1;
     boolean mScreenOnEarly = false;
@@ -339,7 +357,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
     static final int DEFAULT_ACCELEROMETER_ROTATION = 0;
     int mAccelerometerDefault = DEFAULT_ACCELEROMETER_ROTATION;
     boolean mHasSoftInput = false;
-    
+
     int mPointerLocationMode = 0;
     PointerLocationView mPointerLocationView = null;
     InputChannel mPointerLocationInputChannel;
@@ -366,8 +384,9 @@ public class PhoneWindowManager implements WindowManagerPolicy {
             }
         }
     };
-    
-    // The current size of the screen; really; (ir)regardless of whether the status
+
+    // The current size of the screen; really; (ir)regardless of whether the
+    // status
     // bar can be hidden or not
     int mUnrestrictedScreenLeft, mUnrestrictedScreenTop;
     int mUnrestrictedScreenWidth, mUnrestrictedScreenHeight;
@@ -381,7 +400,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
     int mCurLeft, mCurTop, mCurRight, mCurBottom;
     // During layout, the frame in which content should be displayed
     // to the user, accounting for all screen decoration except for any
-    // space they deem as available for other content.  This is usually
+    // space they deem as available for other content. This is usually
     // the same as mCur*, but may be larger if the screen decor has supplied
     // content insets.
     int mContentLeft, mContentTop, mContentRight, mContentBottom;
@@ -408,7 +427,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
     static final Rect mTmpContentFrame = new Rect();
     static final Rect mTmpVisibleFrame = new Rect();
     static final Rect mTmpNavigationFrame = new Rect();
-    
+
     WindowState mTopFullscreenOpaqueWindowState;
     boolean mTopIsFullscreen;
     boolean mForceStatusBar;
@@ -426,23 +445,25 @@ public class PhoneWindowManager implements WindowManagerPolicy {
     int mLockScreenTimeout;
     boolean mLockScreenTimerActive;
 
-    // Behavior of ENDCALL Button.  (See Settings.System.END_BUTTON_BEHAVIOR.)
+    // Behavior of ENDCALL Button. (See Settings.System.END_BUTTON_BEHAVIOR.)
     int mEndcallBehavior;
 
     // Behavior of POWER button while in-call and screen on.
     // (See Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR.)
     int mIncallPowerBehavior;
 
-    int mLandscapeRotation = 0;  // default landscape rotation
-    int mSeascapeRotation = 0;   // "other" landscape rotation, 180 degrees from mLandscapeRotation
-    int mPortraitRotation = 0;   // default portrait rotation
+    int mLandscapeRotation = 0; // default landscape rotation
+    int mSeascapeRotation = 0; // "other" landscape rotation, 180 degrees from
+                               // mLandscapeRotation
+    int mPortraitRotation = 0; // default portrait rotation
     int mUpsideDownRotation = 0; // "other" portrait rotation
 
     // What we do when the user long presses on home
     private int mLongPressOnHomeBehavior = -1;
 
     // Screenshot trigger states
-    // Time to volume and power must be pressed within this interval of each other.
+    // Time to volume and power must be pressed within this interval of each
+    // other.
     private static final long SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS = 150;
     private boolean mVolumeDownKeyTriggered;
     private long mVolumeDownKeyTime;
@@ -491,29 +512,32 @@ public class PhoneWindowManager implements WindowManagerPolicy {
             updateSettings();
         }
 
-        @Override public void onChange(boolean selfChange) {
+        @Override
+        public void onChange(boolean selfChange) {
             updateSettings();
             updateRotation(false);
         }
     }
-    
+
     class MyOrientationListener extends WindowOrientationListener {
         MyOrientationListener(Context context) {
             super(context);
         }
-        
+
         @Override
         public void onProposedRotationChanged(int rotation) {
-            if (localLOGV) Log.v(TAG, "onProposedRotationChanged, rotation=" + rotation);
+            if (localLOGV)
+                Log.v(TAG, "onProposedRotationChanged, rotation=" + rotation);
             updateRotation(false);
         }
     }
+
     MyOrientationListener mOrientationListener;
 
     /*
-     * We always let the sensor be switched on by default except when
-     * the user has explicitly disabled sensor based rotation or when the
-     * screen is switched off.
+     * We always let the sensor be switched on by default except when the user
+     * has explicitly disabled sensor based rotation or when the screen is
+     * switched off.
      */
     boolean needSensorRunningLp() {
         if (mCurrentAppOrientation == ActivityInfo.SCREEN_ORIENTATION_SENSOR
@@ -528,60 +552,63 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                 (mDeskDockEnablesAccelerometer && (mDockMode == Intent.EXTRA_DOCK_STATE_DESK
                         || mDockMode == Intent.EXTRA_DOCK_STATE_LE_DESK
                         || mDockMode == Intent.EXTRA_DOCK_STATE_HE_DESK))) {
-            // enable accelerometer if we are docked in a dock that enables accelerometer
+            // enable accelerometer if we are docked in a dock that enables
+            // accelerometer
             // orientation management,
             return true;
         }
         if (mAccelerometerDefault == 0) {
             // If the setting for using the sensor by default is enabled, then
-            // we will always leave it on.  Note that the user could go to
+            // we will always leave it on. Note that the user could go to
             // a window that forces an orientation that does not use the
             // sensor and in theory we could turn it off... however, when next
             // turning it on we won't have a good value for the current
             // orientation for a little bit, which can cause orientation
-            // changes to lag, so we'd like to keep it always on.  (It will
+            // changes to lag, so we'd like to keep it always on. (It will
             // still be turned off when the screen is off.)
             return false;
         }
         return true;
     }
-    
+
     /*
-     * Various use cases for invoking this function
-     * screen turning off, should always disable listeners if already enabled
-     * screen turned on and current app has sensor based orientation, enable listeners 
-     * if not already enabled
-     * screen turned on and current app does not have sensor orientation, disable listeners if
-     * already enabled
-     * screen turning on and current app has sensor based orientation, enable listeners if needed
-     * screen turning on and current app has nosensor based orientation, do nothing
+     * Various use cases for invoking this function screen turning off, should
+     * always disable listeners if already enabled screen turned on and current
+     * app has sensor based orientation, enable listeners if not already enabled
+     * screen turned on and current app does not have sensor orientation,
+     * disable listeners if already enabled screen turning on and current app
+     * has sensor based orientation, enable listeners if needed screen turning
+     * on and current app has nosensor based orientation, do nothing
      */
     void updateOrientationListenerLp() {
         if (!mOrientationListener.canDetectOrientation()) {
             // If sensor is turned off or nonexistent for some reason
             return;
         }
-        //Could have been invoked due to screen turning on or off or
-        //change of the currently visible window's orientation
-        if (localLOGV) Log.v(TAG, "Screen status="+mScreenOnEarly+
-                ", current orientation="+mCurrentAppOrientation+
-                ", SensorEnabled="+mOrientationSensorEnabled);
+        // Could have been invoked due to screen turning on or off or
+        // change of the currently visible window's orientation
+        if (localLOGV)
+            Log.v(TAG, "Screen status=" + mScreenOnEarly +
+                    ", current orientation=" + mCurrentAppOrientation +
+                    ", SensorEnabled=" + mOrientationSensorEnabled);
         boolean disable = true;
         if (mScreenOnEarly) {
             if (needSensorRunningLp()) {
                 disable = false;
-                //enable listener if not already enabled
+                // enable listener if not already enabled
                 if (!mOrientationSensorEnabled) {
                     mOrientationListener.enable();
-                    if(localLOGV) Log.v(TAG, "Enabling listeners");
+                    if (localLOGV)
+                        Log.v(TAG, "Enabling listeners");
                     mOrientationSensorEnabled = true;
                 }
-            } 
-        } 
-        //check if sensors need to be disabled
+            }
+        }
+        // check if sensors need to be disabled
         if (disable && mOrientationSensorEnabled) {
             mOrientationListener.disable();
-            if(localLOGV) Log.v(TAG, "Disabling listeners");
+            if (localLOGV)
+                Log.v(TAG, "Disabling listeners");
             mOrientationSensorEnabled = false;
         }
     }
@@ -636,7 +664,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                         com.android.internal.R.integer.config_longPressOnPowerBehavior);
             }
             switch (mLongPressOnPowerBehavior) {
-            case LONG_PRESS_POWER_NOTHING:
+                case LONG_PRESS_POWER_NOTHING:
                 break;
             case LONG_PRESS_POWER_GLOBAL_ACTIONS:
                 mPowerKeyHandled = true;
@@ -650,8 +678,8 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                 sendCloseSystemWindows(SYSTEM_DIALOG_REASON_GLOBAL_ACTIONS);
                 ShutdownThread.shutdown(mContext, true);
                 break;
-            }
         }
+    }
     };
 
     private final Runnable mScreenshotChordLongPress = new Runnable() {
@@ -679,10 +707,11 @@ public class PhoneWindowManager implements WindowManagerPolicy {
     }
 
     private void handleLongPressOnHome() {
-        // We can't initialize this in init() since the configuration hasn't been loaded yet.
+        // We can't initialize this in init() since the configuration hasn't
+        // been loaded yet.
         if (mLongPressOnHomeBehavior < 0) {
-            mLongPressOnHomeBehavior
-                    = mContext.getResources().getInteger(R.integer.config_longPressOnHomeBehavior);
+            mLongPressOnHomeBehavior = mContext.getResources().getInteger(
+                    R.integer.config_longPressOnHomeBehavior);
             if (mLongPressOnHomeBehavior < LONG_PRESS_HOME_NOTHING ||
                     mLongPressOnHomeBehavior > LONG_PRESS_HOME_RECENT_SYSTEM_UI) {
                 mLongPressOnHomeBehavior = LONG_PRESS_HOME_NOTHING;
@@ -710,8 +739,8 @@ public class PhoneWindowManager implements WindowManagerPolicy {
     }
 
     /**
-     * Create (if necessary) and show or dismiss the recent apps dialog according
-     * according to the requested behavior.
+     * Create (if necessary) and show or dismiss the recent apps dialog
+     * according according to the requested behavior.
      */
     void showOrHideRecentAppsDialog(final int behavior) {
         mHandler.post(new Runnable() {
@@ -766,30 +795,35 @@ public class PhoneWindowManager implements WindowManagerPolicy {
         mOrientationListener = new MyOrientationListener(mContext);
         try {
             mOrientationListener.setCurrentRotation(windowManager.getRotation());
-        } catch (RemoteException ex) { }
+        } catch (RemoteException ex) {
+        }
         SettingsObserver settingsObserver = new SettingsObserver(mHandler);
         settingsObserver.observe();
         mShortcutManager = new ShortcutManager(context, mHandler);
         mShortcutManager.observe();
-        mHomeIntent =  new Intent(Intent.ACTION_MAIN, null);
+        mHomeIntent = new Intent(Intent.ACTION_MAIN, null);
         mHomeIntent.addCategory(Intent.CATEGORY_HOME);
         mHomeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK
                 | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
-        mCarDockIntent =  new Intent(Intent.ACTION_MAIN, null);
+        mCarDockIntent = new Intent(Intent.ACTION_MAIN, null);
         mCarDockIntent.addCategory(Intent.CATEGORY_CAR_DOCK);
         mCarDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK
                 | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
-        mDeskDockIntent =  new Intent(Intent.ACTION_MAIN, null);
+        mDeskDockIntent = new Intent(Intent.ACTION_MAIN, null);
         mDeskDockIntent.addCategory(Intent.CATEGORY_DESK_DOCK);
         mDeskDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK
                 | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
 
-        PowerManager pm = (PowerManager)context.getSystemService(Context.POWER_SERVICE);
+        PowerManager pm = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
         mBroadcastWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,
                 "PhoneWindowManager.mBroadcastWakeLock");
         mEnableShiftMenuBugReports = "1".equals(SystemProperties.get("ro.debuggable"));
         mLidOpenRotation = readRotation(
                 com.android.internal.R.integer.config_lidOpenRotation);
+        mLidInflueceRotation = com.android.internal.R.integer.config_lidInfluecesRotation;
+        mConvertibleInflueceRotation = com.android.internal.R.integer.config_convertibleInfluecesRotation;
+        mConvertibleRotation = readRotation(
+                        com.android.internal.R.integer.config_convertibleRotation);
         mCarDockRotation = readRotation(
                 com.android.internal.R.integer.config_carDockRotation);
         mDeskDockRotation = readRotation(
@@ -800,6 +834,8 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                 com.android.internal.R.bool.config_deskDockEnablesAccelerometer);
         mLidKeyboardAccessibility = mContext.getResources().getInteger(
                 com.android.internal.R.integer.config_lidKeyboardAccessibility);
+        mConvertibleKeyboardAccessibility = mContext.getResources().getInteger(
+                com.android.internal.R.integer.config_convertibleKeyboardAccessibility);
         mLidNavigationAccessibility = mContext.getResources().getInteger(
                 com.android.internal.R.integer.config_lidNavigationAccessibility);
         // register for dock events
@@ -868,7 +904,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
         }
 
         // Determine whether the status bar can hide based on the size
-        // of the screen.  We assume sizes > 600dp are tablets where we
+        // of the screen. We assume sizes > 600dp are tablets where we
         // will use the system bar.
         int shortSizeDp = shortSize
                 * DisplayMetrics.DENSITY_DEFAULT
@@ -876,26 +912,28 @@ public class PhoneWindowManager implements WindowManagerPolicy {
         mStatusBarCanHide = shortSizeDp < 600;
         mStatusBarHeight = mContext.getResources().getDimensionPixelSize(
                 mStatusBarCanHide
-                ? com.android.internal.R.dimen.status_bar_height
-                : com.android.internal.R.dimen.system_bar_height);
+                        ? com.android.internal.R.dimen.status_bar_height
+                        : com.android.internal.R.dimen.system_bar_height);
 
         mHasNavigationBar = mContext.getResources().getBoolean(
                 com.android.internal.R.bool.config_showNavigationBar);
         // Allow a system property to override this. Used by the emulator.
         // See also hasNavigationBar().
         String navBarOverride = SystemProperties.get("qemu.hw.mainkeys");
-        if (! "".equals(navBarOverride)) {
-            if      (navBarOverride.equals("1")) mHasNavigationBar = false;
-            else if (navBarOverride.equals("0")) mHasNavigationBar = true;
+        if (!"".equals(navBarOverride)) {
+            if (navBarOverride.equals("1"))
+                mHasNavigationBar = false;
+            else if (navBarOverride.equals("0"))
+                mHasNavigationBar = true;
         }
 
         mNavigationBarHeight = mHasNavigationBar
                 ? mContext.getResources().getDimensionPixelSize(
-                    com.android.internal.R.dimen.navigation_bar_height)
+                        com.android.internal.R.dimen.navigation_bar_height)
                 : 0;
         mNavigationBarWidth = mHasNavigationBar
                 ? mContext.getResources().getDimensionPixelSize(
-                    com.android.internal.R.dimen.navigation_bar_width)
+                        com.android.internal.R.dimen.navigation_bar_width)
                 : 0;
 
         if ("portrait".equals(SystemProperties.get("persist.demo.hdmirotation"))) {
@@ -919,11 +957,11 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                     Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR_DEFAULT);
             int accelerometerDefault = Settings.System.getInt(resolver,
                     Settings.System.ACCELEROMETER_ROTATION, DEFAULT_ACCELEROMETER_ROTATION);
-            
+
             // set up rotation lock state
             mUserRotationMode = (accelerometerDefault == 0)
-                ? WindowManagerPolicy.USER_ROTATION_LOCKED
-                : WindowManagerPolicy.USER_ROTATION_FREE;
+                    ? WindowManagerPolicy.USER_ROTATION_LOCKED
+                    : WindowManagerPolicy.USER_ROTATION_FREE;
             mUserRotation = Settings.System.getInt(resolver,
                     Settings.System.USER_ROTATION,
                     Surface.ROTATION_0);
@@ -983,11 +1021,11 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                     mContext.getSystemService(Context.WINDOW_SERVICE);
             lp.inputFeatures |= WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL;
             wm.addView(addView, lp);
-            
+
             if (mPointerLocationInputChannel == null) {
                 try {
                     mPointerLocationInputChannel =
-                        mWindowManager.monitorInput("PointerLocationView");
+                            mWindowManager.monitorInput("PointerLocationView");
                     InputQueue.registerInputChannel(mPointerLocationInputChannel,
                             mPointerLocationInputHandler, mHandler.getLooper().getQueue());
                 } catch (RemoteException ex) {
@@ -1002,13 +1040,13 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                 mPointerLocationInputChannel.dispose();
                 mPointerLocationInputChannel = null;
             }
-            
+
             WindowManager wm = (WindowManager)
                     mContext.getSystemService(Context.WINDOW_SERVICE);
             wm.removeView(removeView);
         }
     }
-    
+
     private int readRotation(int resID) {
         try {
             int rotation = mContext.getResources().getInteger(resID);
@@ -1031,7 +1069,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
     /** {@inheritDoc} */
     public int checkAddPermission(WindowManager.LayoutParams attrs) {
         int type = attrs.type;
-        
+
         if (type < WindowManager.LayoutParams.FIRST_SYSTEM_WINDOW
                 || type > WindowManager.LayoutParams.LAST_SYSTEM_WINDOW) {
             return WindowManagerImpl.ADD_OKAY;
@@ -1040,7 +1078,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
         switch (type) {
             case TYPE_TOAST:
                 // XXX right now the app process has complete control over
-                // this...  should introduce a token to let the system
+                // this... should introduce a token to let the system
                 // monitor/control what they are doing.
                 break;
             case TYPE_INPUT_METHOD:
@@ -1058,14 +1096,13 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                 permission = android.Manifest.permission.INTERNAL_SYSTEM_WINDOW;
         }
         if (permission != null) {
-            if (mContext.checkCallingOrSelfPermission(permission)
-                    != PackageManager.PERMISSION_GRANTED) {
+            if (mContext.checkCallingOrSelfPermission(permission) != PackageManager.PERMISSION_GRANTED) {
                 return WindowManagerImpl.ADD_PERMISSION_DENIED;
             }
         }
         return WindowManagerImpl.ADD_OKAY;
     }
-    
+
     public void adjustWindowParamsLw(WindowManager.LayoutParams attrs) {
         switch (attrs.type) {
             case TYPE_SYSTEM_OVERLAY:
@@ -1078,7 +1115,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                 break;
         }
     }
-    
+
     void readLidState() {
         try {
             int sw = mWindowManager.getSwitchState(SW_LID);
@@ -1093,8 +1130,24 @@ public class PhoneWindowManager implements WindowManagerPolicy {
             // Ignore
         }
     }
-    
-    private int determineHiddenState(int mode, int hiddenValue, int visibleValue) {
+
+    void readConvertibleState() {
+        try {
+            int sw = mWindowManager.getSwitchState(SW_TABLET_MODE);
+            Log.v(TAG, "readConvertibleState:" + sw);
+            if (sw > 0) {
+                mConvertible = CONVERTIBLE_CLOSED;
+            } else if (sw == 0) {
+                mConvertible = CONVERTIBLE_OPEN;
+            } else {
+                mConvertible = CONVERTIBLE_ABSENT; // means not available
+            }
+        } catch (RemoteException e) {
+            // Ignore
+        }
+    }
+
+    private int determineHiddenStateLid(int mode, int hiddenValue, int visibleValue) {
         if (mLidOpen != LID_ABSENT) {
             switch (mode) {
                 case 1:
@@ -1106,22 +1159,48 @@ public class PhoneWindowManager implements WindowManagerPolicy {
         return visibleValue;
     }
 
+    private int determineHiddenStateConvertible(int mode, int hiddenValue, int visibleValue) {
+        Log.v(TAG, "determineHiddenState Convertible");
+        if (mConvertible != CONVERTIBLE_ABSENT) {
+            switch (mode) {
+                case 1:
+                    return mConvertible == CONVERTIBLE_OPEN ? visibleValue : hiddenValue;
+                case 2:
+                    return mConvertible == CONVERTIBLE_OPEN ? hiddenValue : visibleValue;
+            }
+        }
+        return visibleValue;
+    }
+
     /** {@inheritDoc} */
     public void adjustConfigurationLw(Configuration config) {
         readLidState();
+        readConvertibleState();
+
         updateKeyboardVisibility();
 
         if (config.keyboard == Configuration.KEYBOARD_NOKEYS) {
             config.hardKeyboardHidden = Configuration.HARDKEYBOARDHIDDEN_YES;
         } else {
-            config.hardKeyboardHidden = determineHiddenState(mLidKeyboardAccessibility,
-                    Configuration.HARDKEYBOARDHIDDEN_YES, Configuration.HARDKEYBOARDHIDDEN_NO);
+            if (mConvertible != CONVERTIBLE_ABSENT) {
+                Log.v(TAG, "KeyboardHidden convertible:" + mConvertible);
+                config.hardKeyboardHidden = determineHiddenStateConvertible(
+                                        mConvertibleKeyboardAccessibility,
+                                        Configuration.HARDKEYBOARDHIDDEN_YES,
+                        Configuration.HARDKEYBOARDHIDDEN_NO);
+            } else {
+                Log.v(TAG, "KeyboardHidden lid");
+                config.hardKeyboardHidden = determineHiddenStateLid(mLidKeyboardAccessibility,
+                                        Configuration.HARDKEYBOARDHIDDEN_YES,
+                        Configuration.HARDKEYBOARDHIDDEN_NO);
+            }
+
         }
 
         if (config.navigation == Configuration.NAVIGATION_NONAV) {
             config.navigationHidden = Configuration.NAVIGATIONHIDDEN_YES;
         } else {
-            config.navigationHidden = determineHiddenState(mLidNavigationAccessibility,
+            config.navigationHidden = determineHiddenStateLid(mLidNavigationAccessibility,
                     Configuration.NAVIGATIONHIDDEN_YES, Configuration.NAVIGATIONHIDDEN_NO);
         }
 
@@ -1138,52 +1217,52 @@ public class PhoneWindowManager implements WindowManagerPolicy {
             return APPLICATION_LAYER;
         }
         switch (type) {
-        case TYPE_STATUS_BAR:
-            return STATUS_BAR_LAYER;
-        case TYPE_STATUS_BAR_PANEL:
-            return STATUS_BAR_PANEL_LAYER;
-        case TYPE_STATUS_BAR_SUB_PANEL:
-            return STATUS_BAR_SUB_PANEL_LAYER;
-        case TYPE_SYSTEM_DIALOG:
-            return SYSTEM_DIALOG_LAYER;
-        case TYPE_SEARCH_BAR:
-            return SEARCH_BAR_LAYER;
-        case TYPE_PHONE:
-            return PHONE_LAYER;
-        case TYPE_KEYGUARD:
-            return KEYGUARD_LAYER;
-        case TYPE_KEYGUARD_DIALOG:
-            return KEYGUARD_DIALOG_LAYER;
-        case TYPE_SYSTEM_ALERT:
-            return SYSTEM_ALERT_LAYER;
-        case TYPE_SYSTEM_ERROR:
-            return SYSTEM_ERROR_LAYER;
-        case TYPE_INPUT_METHOD:
-            return INPUT_METHOD_LAYER;
-        case TYPE_INPUT_METHOD_DIALOG:
-            return INPUT_METHOD_DIALOG_LAYER;
-        case TYPE_VOLUME_OVERLAY:
-            return VOLUME_OVERLAY_LAYER;
-        case TYPE_SYSTEM_OVERLAY:
-            return SYSTEM_OVERLAY_LAYER;
-        case TYPE_SECURE_SYSTEM_OVERLAY:
-            return SECURE_SYSTEM_OVERLAY_LAYER;
-        case TYPE_PRIORITY_PHONE:
-            return PRIORITY_PHONE_LAYER;
-        case TYPE_TOAST:
-            return TOAST_LAYER;
-        case TYPE_WALLPAPER:
-            return WALLPAPER_LAYER;
-        case TYPE_DRAG:
-            return DRAG_LAYER;
-        case TYPE_POINTER:
-            return POINTER_LAYER;
-        case TYPE_NAVIGATION_BAR:
-            return NAVIGATION_BAR_LAYER;
-        case TYPE_BOOT_PROGRESS:
-            return BOOT_PROGRESS_LAYER;
-        case TYPE_HIDDEN_NAV_CONSUMER:
-            return HIDDEN_NAV_CONSUMER_LAYER;
+            case TYPE_STATUS_BAR:
+                return STATUS_BAR_LAYER;
+            case TYPE_STATUS_BAR_PANEL:
+                return STATUS_BAR_PANEL_LAYER;
+            case TYPE_STATUS_BAR_SUB_PANEL:
+                return STATUS_BAR_SUB_PANEL_LAYER;
+            case TYPE_SYSTEM_DIALOG:
+                return SYSTEM_DIALOG_LAYER;
+            case TYPE_SEARCH_BAR:
+                return SEARCH_BAR_LAYER;
+            case TYPE_PHONE:
+                return PHONE_LAYER;
+            case TYPE_KEYGUARD:
+                return KEYGUARD_LAYER;
+            case TYPE_KEYGUARD_DIALOG:
+                return KEYGUARD_DIALOG_LAYER;
+            case TYPE_SYSTEM_ALERT:
+                return SYSTEM_ALERT_LAYER;
+            case TYPE_SYSTEM_ERROR:
+                return SYSTEM_ERROR_LAYER;
+            case TYPE_INPUT_METHOD:
+                return INPUT_METHOD_LAYER;
+            case TYPE_INPUT_METHOD_DIALOG:
+                return INPUT_METHOD_DIALOG_LAYER;
+            case TYPE_VOLUME_OVERLAY:
+                return VOLUME_OVERLAY_LAYER;
+            case TYPE_SYSTEM_OVERLAY:
+                return SYSTEM_OVERLAY_LAYER;
+            case TYPE_SECURE_SYSTEM_OVERLAY:
+                return SECURE_SYSTEM_OVERLAY_LAYER;
+            case TYPE_PRIORITY_PHONE:
+                return PRIORITY_PHONE_LAYER;
+            case TYPE_TOAST:
+                return TOAST_LAYER;
+            case TYPE_WALLPAPER:
+                return WALLPAPER_LAYER;
+            case TYPE_DRAG:
+                return DRAG_LAYER;
+            case TYPE_POINTER:
+                return POINTER_LAYER;
+            case TYPE_NAVIGATION_BAR:
+                return NAVIGATION_BAR_LAYER;
+            case TYPE_BOOT_PROGRESS:
+                return BOOT_PROGRESS_LAYER;
+            case TYPE_HIDDEN_NAV_CONSUMER:
+                return HIDDEN_NAV_CONSUMER_LAYER;
         }
         Log.e(TAG, "Unknown window type: " + type);
         return APPLICATION_LAYER;
@@ -1192,15 +1271,15 @@ public class PhoneWindowManager implements WindowManagerPolicy {
     /** {@inheritDoc} */
     public int subWindowTypeToLayerLw(int type) {
         switch (type) {
-        case TYPE_APPLICATION_PANEL:
-        case TYPE_APPLICATION_ATTACHED_DIALOG:
-            return APPLICATION_PANEL_SUBLAYER;
-        case TYPE_APPLICATION_MEDIA:
-            return APPLICATION_MEDIA_SUBLAYER;
-        case TYPE_APPLICATION_MEDIA_OVERLAY:
-            return APPLICATION_MEDIA_OVERLAY_SUBLAYER;
-        case TYPE_APPLICATION_SUB_PANEL:
-            return APPLICATION_SUB_PANEL_SUBLAYER;
+            case TYPE_APPLICATION_PANEL:
+            case TYPE_APPLICATION_ATTACHED_DIALOG:
+                return APPLICATION_PANEL_SUBLAYER;
+            case TYPE_APPLICATION_MEDIA:
+                return APPLICATION_MEDIA_SUBLAYER;
+            case TYPE_APPLICATION_MEDIA_OVERLAY:
+                return APPLICATION_MEDIA_OVERLAY_SUBLAYER;
+            case TYPE_APPLICATION_SUB_PANEL:
+                return APPLICATION_SUB_PANEL_SUBLAYER;
         }
         Log.e(TAG, "Unknown sub-window type: " + type);
         return 0;
@@ -1215,7 +1294,8 @@ public class PhoneWindowManager implements WindowManagerPolicy {
     }
 
     public int getNonDecorDisplayWidth(int fullWidth, int fullHeight, int rotation) {
-        // Assumes that the navigation bar appears on the side of the display in landscape.
+        // Assumes that the navigation bar appears on the side of the display in
+        // landscape.
         if (fullWidth > fullHeight) {
             return fullWidth - mNavigationBarWidth;
         }
@@ -1223,10 +1303,11 @@ public class PhoneWindowManager implements WindowManagerPolicy {
     }
 
     public int getNonDecorDisplayHeight(int fullWidth, int fullHeight, int rotation) {
-        // Assumes the navigation bar appears on the bottom of the display in portrait.
+        // Assumes the navigation bar appears on the bottom of the display in
+        // portrait.
         return fullHeight
-            - (mStatusBarCanHide ? 0 : mStatusBarHeight)
-            - ((fullWidth > fullHeight) ? 0 : mNavigationBarHeight);
+                - (mStatusBarCanHide ? 0 : mStatusBarHeight)
+                - ((fullWidth > fullHeight) ? 0 : mNavigationBarHeight);
     }
 
     public int getConfigDisplayWidth(int fullWidth, int fullHeight, int rotation) {
@@ -1235,7 +1316,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
 
     public int getConfigDisplayHeight(int fullWidth, int fullHeight, int rotation) {
         // This is the same as getNonDecorDisplayHeight, unless the status bar
-        // can hide.  If the status bar can hide, we don't count that as part
+        // can hide. If the status bar can hide, we don't count that as part
         // of the decor; however for purposes of configurations, we do want to
         // exclude it since applications can't generally use that part of the
         // screen.
@@ -1246,12 +1327,12 @@ public class PhoneWindowManager implements WindowManagerPolicy {
     public boolean doesForceHide(WindowState win, WindowManager.LayoutParams attrs) {
         return attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD;
     }
-    
+
     public boolean canBeForceHidden(WindowState win, WindowManager.LayoutParams attrs) {
         return attrs.type != WindowManager.LayoutParams.TYPE_STATUS_BAR
                 && attrs.type != WindowManager.LayoutParams.TYPE_WALLPAPER;
     }
-    
+
     /** {@inheritDoc} */
     public View addStartingWindow(IBinder appToken, String packageName, int theme,
             CompatibilityInfo compatInfo, CharSequence nonLocalizedLabel, int labelRes,
@@ -1262,11 +1343,12 @@ public class PhoneWindowManager implements WindowManagerPolicy {
         if (packageName == null) {
             return null;
         }
-        
+
         try {
             Context context = mContext;
-            //Log.i(TAG, "addStartingWindow " + packageName + ": nonLocalizedLabel="
-            //        + nonLocalizedLabel + " theme=" + Integer.toHexString(theme));
+            // Log.i(TAG, "addStartingWindow " + packageName +
+            // ": nonLocalizedLabel="
+            // + nonLocalizedLabel + " theme=" + Integer.toHexString(theme));
             if (theme != context.getThemeResId() || labelRes != 0) {
                 try {
                     context = context.createPackageContext(packageName, 0);
@@ -1275,39 +1357,42 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                     // Ignore
                 }
             }
-            
+
             Window win = PolicyManager.makeNewWindow(context);
             if (win.getWindowStyle().getBoolean(
                     com.android.internal.R.styleable.Window_windowDisablePreview, false)) {
                 return null;
             }
-            
+
             Resources r = context.getResources();
             win.setTitle(r.getText(labelRes, nonLocalizedLabel));
-    
+
             win.setType(
-                WindowManager.LayoutParams.TYPE_APPLICATION_STARTING);
-            // Force the window flags: this is a fake window, so it is not really
-            // touchable or focusable by the user.  We also add in the ALT_FOCUSABLE_IM
+                    WindowManager.LayoutParams.TYPE_APPLICATION_STARTING);
+            // Force the window flags: this is a fake window, so it is not
+            // really
+            // touchable or focusable by the user. We also add in the
+            // ALT_FOCUSABLE_IM
             // flag because we do know that the next window will take input
-            // focus, so we want to get the IME window up on top of us right away.
+            // focus, so we want to get the IME window up on top of us right
+            // away.
             win.setFlags(
-                windowFlags|
-                WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE|
-                WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE|
-                WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM,
-                windowFlags|
-                WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE|
-                WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE|
-                WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);
-    
+                    windowFlags |
+                            WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE |
+                            WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE |
+                            WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM,
+                    windowFlags |
+                            WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE |
+                            WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE |
+                            WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);
+
             if (!compatInfo.supportsScreen()) {
                 win.addFlags(WindowManager.LayoutParams.FLAG_COMPATIBLE_WINDOW);
             }
 
             win.setLayout(WindowManager.LayoutParams.MATCH_PARENT,
                     WindowManager.LayoutParams.MATCH_PARENT);
-    
+
             final WindowManager.LayoutParams params = win.getAttributes();
             params.token = appToken;
             params.packageName = packageName;
@@ -1317,23 +1402,24 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                     WindowManager.LayoutParams.PRIVATE_FLAG_FAKE_HARDWARE_ACCELERATED;
             params.setTitle("Starting " + packageName);
 
-            WindowManager wm = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
+            WindowManager wm = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
             View view = win.getDecorView();
 
             if (win.isFloating()) {
                 // Whoops, there is no way to display an animation/preview
-                // of such a thing!  After all that work...  let's skip it.
+                // of such a thing! After all that work... let's skip it.
                 // (Note that we must do this here because it is in
-                // getDecorView() where the theme is evaluated...  maybe
+                // getDecorView() where the theme is evaluated... maybe
                 // we should peek the floating attribute from the theme
                 // earlier.)
                 return null;
             }
-            
-            if (localLOGV) Log.v(
-                TAG, "Adding starting window for " + packageName
-                + " / " + appToken + ": "
-                + (view.getParent() != null ? view : null));
+
+            if (localLOGV)
+                Log.v(
+                        TAG, "Adding starting window for " + packageName
+                                + " / " + appToken + ": "
+                                + (view.getParent() != null ? view : null));
 
             wm.addView(view, params);
 
@@ -1358,19 +1444,19 @@ public class PhoneWindowManager implements WindowManagerPolicy {
         // RuntimeException e = new RuntimeException();
         // Log.i(TAG, "remove " + appToken + " " + window, e);
 
-        if (localLOGV) Log.v(
-            TAG, "Removing starting window for " + appToken + ": " + window);
+        if (localLOGV)
+            Log.v(
+                    TAG, "Removing starting window for " + appToken + ": " + window);
 
         if (window != null) {
-            WindowManager wm = (WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE);
+            WindowManager wm = (WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE);
             wm.removeView(window);
         }
     }
 
     /**
-     * Preflight adding a window to the system.
-     * 
-     * Currently enforces that three window types are singletons:
+     * Preflight adding a window to the system. Currently enforces that three
+     * window types are singletons:
      * <ul>
      * <li>STATUS_BAR_TYPE</li>
      * <li>KEYGUARD_TYPE</li>
@@ -1378,8 +1464,8 @@ public class PhoneWindowManager implements WindowManagerPolicy {
      * 
      * @param win The window to be added
      * @param attrs Information about the window to be added
-     * 
-     * @return If ok, WindowManagerImpl.ADD_OKAY.  If too many singletons, WindowManagerImpl.ADD_MULTIPLE_SINGLETON
+     * @return If ok, WindowManagerImpl.ADD_OKAY. If too many singletons,
+     *         WindowManagerImpl.ADD_MULTIPLE_SINGLETON
      */
     public int prepareAddWindowLw(WindowState win, WindowManager.LayoutParams attrs) {
         switch (attrs.type) {
@@ -1387,8 +1473,10 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                 mContext.enforceCallingOrSelfPermission(
                         android.Manifest.permission.STATUS_BAR_SERVICE,
                         "PhoneWindowManager");
-                // TODO: Need to handle the race condition of the status bar proc
-                // dying and coming back before the removeWindowLw cleanup has happened.
+                // TODO: Need to handle the race condition of the status bar
+                // proc
+                // dying and coming back before the removeWindowLw cleanup has
+                // happened.
                 if (mStatusBar != null) {
                     return WindowManagerImpl.ADD_MULTIPLE_SINGLETON;
                 }
@@ -1399,7 +1487,8 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                         android.Manifest.permission.STATUS_BAR_SERVICE,
                         "PhoneWindowManager");
                 mNavigationBar = win;
-                if (DEBUG_LAYOUT) Log.i(TAG, "NAVIGATION BAR: " + mNavigationBar);
+                if (DEBUG_LAYOUT)
+                    Log.i(TAG, "NAVIGATION BAR: " + mNavigationBar);
                 break;
             case TYPE_STATUS_BAR_PANEL:
                 mContext.enforceCallingOrSelfPermission(
@@ -1437,14 +1526,16 @@ public class PhoneWindowManager implements WindowManagerPolicy {
     }
 
     static final boolean PRINT_ANIM = false;
-    
+
     /** {@inheritDoc} */
     public int selectAnimationLw(WindowState win, int transit) {
-        if (PRINT_ANIM) Log.i(TAG, "selectAnimation in " + win
-              + ": transit=" + transit);
+        if (PRINT_ANIM)
+            Log.i(TAG, "selectAnimation in " + win
+                    + ": transit=" + transit);
         if (transit == TRANSIT_PREVIEW_DONE) {
             if (win.hasAppShownWindows()) {
-                if (PRINT_ANIM) Log.i(TAG, "**** STARTING EXIT");
+                if (PRINT_ANIM)
+                    Log.i(TAG, "**** STARTING EXIT");
                 return com.android.internal.R.anim.app_starting_exit;
             }
         }
@@ -1456,7 +1547,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
         return AnimationUtils.loadAnimation(mContext,
                 com.android.internal.R.anim.lock_screen_behind_enter);
     }
-    
+
     static ITelephony getTelephonyService() {
         ITelephony telephonyService = ITelephony.Stub.asInterface(
                 ServiceManager.checkService(Context.TELEPHONY_SERVICE));
@@ -1501,12 +1592,14 @@ public class PhoneWindowManager implements WindowManagerPolicy {
         }
 
         // If we think we might have a volume down & power key chord on the way
-        // but we're not sure, then tell the dispatcher to wait a little while and
+        // but we're not sure, then tell the dispatcher to wait a little while
+        // and
         // try again later before dispatching.
         if ((flags & KeyEvent.FLAG_FALLBACK) == 0) {
             if (mVolumeDownKeyTriggered && !mPowerKeyTriggered) {
                 final long now = SystemClock.uptimeMillis();
-                final long timeoutTime = mVolumeDownKeyTime + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS;
+                final long timeoutTime = mVolumeDownKeyTime
+                        + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS;
                 if (now < timeoutTime) {
                     return timeoutTime - now;
                 }
@@ -1565,7 +1658,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                     return 0;
                 }
                 final int typeCount = WINDOW_TYPES_WHERE_HOME_DOESNT_WORK.length;
-                for (int i=0; i<typeCount; i++) {
+                for (int i = 0; i < typeCount; i++) {
                     if (type == WINDOW_TYPES_WHERE_HOME_DOESNT_WORK[i]) {
                         // don't do anything, but also don't pass it to the app
                         return -1;
@@ -1632,9 +1725,10 @@ public class PhoneWindowManager implements WindowManagerPolicy {
 
         // Shortcuts are invoked through Search+key, so intercept those here
         // Any printing key that is chorded with Search should be consumed
-        // even if no shortcut was invoked.  This prevents text from being
+        // even if no shortcut was invoked. This prevents text from being
         // inadvertently inserted when using a keyboard that has built-in macro
-        // shortcut keys (that emit Search+x) and some of them are not registered.
+        // shortcut keys (that emit Search+x) and some of them are not
+        // registered.
         if (mShortcutKeyPressed != -1) {
             final KeyCharacterMap kcm = event.getKeyCharacterMap();
             if (kcm.isPrintingKey(keyCode)) {
@@ -1782,8 +1876,8 @@ public class PhoneWindowManager implements WindowManagerPolicy {
     }
 
     /**
-     * A home key -> launch home action was detected.  Take the appropriate action
-     * given the situation with the keyguard.
+     * A home key -> launch home action was detected. Take the appropriate
+     * action given the situation with the keyguard.
      */
     void launchHomeFromHotKey() {
         if (mKeyguardMediator.isShowingAndNotHidden()) {
@@ -1815,19 +1909,21 @@ public class PhoneWindowManager implements WindowManagerPolicy {
     }
 
     /**
-     * A delayed callback use to determine when it is okay to re-allow applications
-     * to use certain system UI flags.  This is used to prevent applications from
-     * spamming system UI changes that prevent the navigation bar from being shown.
+     * A delayed callback use to determine when it is okay to re-allow
+     * applications to use certain system UI flags. This is used to prevent
+     * applications from spamming system UI changes that prevent the navigation
+     * bar from being shown.
      */
     final Runnable mAllowSystemUiDelay = new Runnable() {
-        @Override public void run() {
+        @Override
+        public void run() {
         }
     };
 
     /**
-     * Input handler used while nav bar is hidden.  Captures any touch on the screen,
-     * to determine when the nav bar should be shown and prevent applications from
-     * receiving those touches.
+     * Input handler used while nav bar is hidden. Captures any touch on the
+     * screen, to determine when the nav bar should be shown and prevent
+     * applications from receiving those touches.
      */
     final InputHandler mHideNavInputHandler = new BaseInputHandler() {
         @Override
@@ -1839,7 +1935,8 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                         // When the user taps down, we re-show the nav bar.
                         boolean changed = false;
                         synchronized (mLock) {
-                            // Any user activity always causes us to show the navigation controls,
+                            // Any user activity always causes us to show the
+                            // navigation controls,
                             // if they had been hidden.
                             int newVal = mResettingSystemUiFlags
                                     | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION;
@@ -1856,7 +1953,8 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                                 mForceClearedSystemUiFlags = newVal;
                                 changed = true;
                                 mHandler.postDelayed(new Runnable() {
-                                    @Override public void run() {
+                                    @Override
+                                    public void run() {
                                         synchronized (mLock) {
                                             mForceClearedSystemUiFlags &=
                                                     ~View.SYSTEM_UI_FLAG_HIDE_NAVIGATION;
@@ -1890,17 +1988,16 @@ public class PhoneWindowManager implements WindowManagerPolicy {
 
     public void getContentInsetHintLw(WindowManager.LayoutParams attrs, Rect contentInset) {
         final int fl = attrs.flags;
-        
-        if ((fl & (FLAG_LAYOUT_IN_SCREEN | FLAG_FULLSCREEN | FLAG_LAYOUT_INSET_DECOR))
-                == (FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR)) {
+
+        if ((fl & (FLAG_LAYOUT_IN_SCREEN | FLAG_FULLSCREEN | FLAG_LAYOUT_INSET_DECOR)) == (FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR)) {
             contentInset.set(mCurLeft, mCurTop,
-                    (mRestrictedScreenLeft+mRestrictedScreenWidth) - mCurRight,
-                    (mRestrictedScreenTop+mRestrictedScreenHeight) - mCurBottom);
+                    (mRestrictedScreenLeft + mRestrictedScreenWidth) - mCurRight,
+                    (mRestrictedScreenTop + mRestrictedScreenHeight) - mCurBottom);
         } else {
             contentInset.setEmpty();
         }
     }
-    
+
     /** {@inheritDoc} */
     public void beginLayoutLw(int displayWidth, int displayHeight, int displayRotation) {
         mUnrestrictedScreenLeft = mUnrestrictedScreenTop = 0;
@@ -1915,7 +2012,8 @@ public class PhoneWindowManager implements WindowManagerPolicy {
         mDockBottom = mContentBottom = mCurBottom = displayHeight;
         mDockLayer = 0x10000000;
 
-        // start with the current dock rect, which will be (0,0,displayWidth,displayHeight)
+        // start with the current dock rect, which will be
+        // (0,0,displayWidth,displayHeight)
         final Rect pf = mTmpParentFrame;
         final Rect df = mTmpDisplayFrame;
         final Rect vf = mTmpVisibleFrame;
@@ -1925,10 +2023,10 @@ public class PhoneWindowManager implements WindowManagerPolicy {
         pf.bottom = df.bottom = vf.bottom = mDockBottom;
 
         final boolean navVisible = (mNavigationBar == null || mNavigationBar.isVisibleLw()) &&
-                (mLastSystemUiFlags&View.SYSTEM_UI_FLAG_HIDE_NAVIGATION) == 0;
+                (mLastSystemUiFlags & View.SYSTEM_UI_FLAG_HIDE_NAVIGATION) == 0;
 
         // When the navigation bar isn't visible, we put up a fake
-        // input window to catch all touch events.  This way we can
+        // input window to catch all touch events. This way we can
         // detect when the user presses anywhere to bring back the nav
         // bar and ensure the application doesn't see the event.
         if (navVisible) {
@@ -1947,32 +2045,36 @@ public class PhoneWindowManager implements WindowManagerPolicy {
         if (mStatusBar != null) {
             if (mNavigationBar != null) {
                 // Force the navigation bar to its appropriate place and
-                // size.  We need to do this directly, instead of relying on
+                // size. We need to do this directly, instead of relying on
                 // it to bubble up from the nav bar, because this needs to
                 // change atomically with screen rotations.
                 if (displayWidth < displayHeight) {
                     // Portrait screen; nav bar goes on bottom.
-                    mTmpNavigationFrame.set(0, displayHeight-mNavigationBarHeight,
+                    mTmpNavigationFrame.set(0, displayHeight - mNavigationBarHeight,
                             displayWidth, displayHeight);
                     if (navVisible) {
                         mDockBottom = mTmpNavigationFrame.top;
                         mRestrictedScreenHeight = mDockBottom - mDockTop;
                     } else {
-                        // We currently want to hide the navigation UI.  Do this by just
-                        // moving it off the screen, so it can still receive input events
+                        // We currently want to hide the navigation UI. Do this
+                        // by just
+                        // moving it off the screen, so it can still receive
+                        // input events
                         // to know when to be re-shown.
                         mTmpNavigationFrame.offset(0, mNavigationBarHeight);
                     }
                 } else {
                     // Landscape screen; nav bar goes to the right.
-                    mTmpNavigationFrame.set(displayWidth-mNavigationBarWidth, 0,
+                    mTmpNavigationFrame.set(displayWidth - mNavigationBarWidth, 0,
                             displayWidth, displayHeight);
                     if (navVisible) {
                         mDockRight = mTmpNavigationFrame.left;
                         mRestrictedScreenWidth = mDockRight - mDockLeft;
                     } else {
-                        // We currently want to hide the navigation UI.  Do this by just
-                        // moving it off the screen, so it can still receive input events
+                        // We currently want to hide the navigation UI. Do this
+                        // by just
+                        // moving it off the screen, so it can still receive
+                        // input events
                         // to know when to be re-shown.
                         mTmpNavigationFrame.offset(mNavigationBarWidth, 0);
                     }
@@ -1980,10 +2082,12 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                 // And compute the final frame.
                 mNavigationBar.computeFrameLw(mTmpNavigationFrame, mTmpNavigationFrame,
                         mTmpNavigationFrame, mTmpNavigationFrame);
-                if (DEBUG_LAYOUT) Log.i(TAG, "mNavigationBar frame: " + mTmpNavigationFrame);
+                if (DEBUG_LAYOUT)
+                    Log.i(TAG, "mNavigationBar frame: " + mTmpNavigationFrame);
             }
-            if (DEBUG_LAYOUT) Log.i(TAG, String.format("mDock rect: (%d,%d - %d,%d)",
-                    mDockLeft, mDockTop, mDockRight, mDockBottom));
+            if (DEBUG_LAYOUT)
+                Log.i(TAG, String.format("mDock rect: (%d,%d - %d,%d)",
+                        mDockLeft, mDockTop, mDockRight, mDockBottom));
 
             // apply navigation bar insets
             pf.left = df.left = vf.left = mDockLeft;
@@ -2001,38 +2105,45 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                     // Status bar may go away, so the screen area it occupies
                     // is available to apps but just covering them when the
                     // status bar is visible.
-                    if (mDockTop == r.top) mDockTop = r.bottom;
-                    else if (mDockBottom == r.bottom) mDockBottom = r.top;
-                    
+                    if (mDockTop == r.top)
+                        mDockTop = r.bottom;
+                    else if (mDockBottom == r.bottom)
+                        mDockBottom = r.top;
+
                     mContentTop = mCurTop = mDockTop;
                     mContentBottom = mCurBottom = mDockBottom;
                     mContentLeft = mCurLeft = mDockLeft;
                     mContentRight = mCurRight = mDockRight;
 
-                    if (DEBUG_LAYOUT) Log.v(TAG, "Status bar: " +
-                        String.format(
-                            "dock=[%d,%d][%d,%d] content=[%d,%d][%d,%d] cur=[%d,%d][%d,%d]",
-                            mDockLeft, mDockTop, mDockRight, mDockBottom,
-                            mContentLeft, mContentTop, mContentRight, mContentBottom,
-                            mCurLeft, mCurTop, mCurRight, mCurBottom));
+                    if (DEBUG_LAYOUT)
+                        Log.v(TAG,
+                                "Status bar: "
+                                        +
+                                        String.format(
+                                                "dock=[%d,%d][%d,%d] content=[%d,%d][%d,%d] cur=[%d,%d][%d,%d]",
+                                                mDockLeft, mDockTop, mDockRight, mDockBottom,
+                                                mContentLeft, mContentTop, mContentRight,
+                                                mContentBottom,
+                                                mCurLeft, mCurTop, mCurRight, mCurBottom));
                 } else {
                     // Status bar can't go away; the part of the screen it
                     // covers does not exist for anything behind it.
                     if (mRestrictedScreenTop == r.top) {
                         mRestrictedScreenTop = r.bottom;
-                        mRestrictedScreenHeight -= (r.bottom-r.top);
-                    } else if ((mRestrictedScreenHeight-mRestrictedScreenTop) == r.bottom) {
-                        mRestrictedScreenHeight -= (r.bottom-r.top);
+                        mRestrictedScreenHeight -= (r.bottom - r.top);
+                    } else if ((mRestrictedScreenHeight - mRestrictedScreenTop) == r.bottom) {
+                        mRestrictedScreenHeight -= (r.bottom - r.top);
                     }
 
                     mContentTop = mCurTop = mDockTop = mRestrictedScreenTop;
                     mContentBottom = mCurBottom = mDockBottom
                             = mRestrictedScreenTop + mRestrictedScreenHeight;
-                    if (DEBUG_LAYOUT) Log.v(TAG, "Status bar: restricted screen area: ("
-                            + mRestrictedScreenLeft + ","
-                            + mRestrictedScreenTop + ","
-                            + (mRestrictedScreenLeft + mRestrictedScreenWidth) + ","
-                            + (mRestrictedScreenTop + mRestrictedScreenHeight) + ")");
+                    if (DEBUG_LAYOUT)
+                        Log.v(TAG, "Status bar: restricted screen area: ("
+                                + mRestrictedScreenLeft + ","
+                                + mRestrictedScreenTop + ","
+                                + (mRestrictedScreenLeft + mRestrictedScreenWidth) + ","
+                                + (mRestrictedScreenTop + mRestrictedScreenHeight) + ")");
                 }
             }
         }
@@ -2045,8 +2156,10 @@ public class PhoneWindowManager implements WindowManagerPolicy {
             // above the dock window, and the window it is attached to is below
             // the dock window, then the frames we computed for the window it is
             // attached to can not be used because the dock is effectively part
-            // of the underlying window and the attached window is floating on top
-            // of the whole thing.  So, we ignore the attached window and explicitly
+            // of the underlying window and the attached window is floating on
+            // top
+            // of the whole thing. So, we ignore the attached window and
+            // explicitly
             // compute the frames that would be appropriate without the dock.
             df.left = cf.left = vf.left = mDockLeft;
             df.top = cf.top = vf.top = mDockTop;
@@ -2054,26 +2167,30 @@ public class PhoneWindowManager implements WindowManagerPolicy {
             df.bottom = cf.bottom = vf.bottom = mDockBottom;
         } else {
             // The effective display frame of the attached window depends on
-            // whether it is taking care of insetting its content.  If not,
+            // whether it is taking care of insetting its content. If not,
             // we need to use the parent's content frame so that the entire
-            // window is positioned within that content.  Otherwise we can use
+            // window is positioned within that content. Otherwise we can use
             // the display frame and let the attached window take care of
             // positioning its content appropriately.
             if (adjust != SOFT_INPUT_ADJUST_RESIZE) {
                 cf.set(attached.getDisplayFrameLw());
             } else {
                 // If the window is resizing, then we want to base the content
-                // frame on our attached content frame to resize...  however,
+                // frame on our attached content frame to resize... however,
                 // things can be tricky if the attached window is NOT in resize
                 // mode, in which case its content frame will be larger.
-                // Ungh.  So to deal with that, make sure the content frame
+                // Ungh. So to deal with that, make sure the content frame
                 // we end up using is not covering the IM dock.
                 cf.set(attached.getContentFrameLw());
                 if (attached.getSurfaceLayer() < mDockLayer) {
-                    if (cf.left < mContentLeft) cf.left = mContentLeft;
-                    if (cf.top < mContentTop) cf.top = mContentTop;
-                    if (cf.right > mContentRight) cf.right = mContentRight;
-                    if (cf.bottom > mContentBottom) cf.bottom = mContentBottom;
+                    if (cf.left < mContentLeft)
+                        cf.left = mContentLeft;
+                    if (cf.top < mContentTop)
+                        cf.top = mContentTop;
+                    if (cf.right > mContentRight)
+                        cf.right = mContentRight;
+                    if (cf.bottom > mContentBottom)
+                        cf.bottom = mContentBottom;
                 }
             }
             df.set(insetDecors ? attached.getDisplayFrameLw() : cf);
@@ -2085,7 +2202,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
         pf.set((fl & FLAG_LAYOUT_IN_SCREEN) == 0
                 ? attached.getFrameLw() : df);
     }
-    
+
     /** {@inheritDoc} */
     public void layoutWindowLw(WindowState win, WindowManager.LayoutParams attrs,
             WindowState attached) {
@@ -2096,13 +2213,13 @@ public class PhoneWindowManager implements WindowManagerPolicy {
 
         final int fl = attrs.flags;
         final int sim = attrs.softInputMode;
-        
+
         final Rect pf = mTmpParentFrame;
         final Rect df = mTmpDisplayFrame;
         final Rect cf = mTmpContentFrame;
         final Rect vf = mTmpVisibleFrame;
-        
-        final boolean hasNavBar = (mHasNavigationBar 
+
+        final boolean hasNavBar = (mHasNavigationBar
                 && mNavigationBar != null && mNavigationBar.isVisibleLw());
 
         if (attrs.type == TYPE_INPUT_METHOD) {
@@ -2116,10 +2233,9 @@ public class PhoneWindowManager implements WindowManagerPolicy {
         } else {
             final int adjust = sim & SOFT_INPUT_MASK_ADJUST;
 
-            if ((fl & (FLAG_LAYOUT_IN_SCREEN | FLAG_FULLSCREEN | FLAG_LAYOUT_INSET_DECOR))
-                    == (FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR)) {
+            if ((fl & (FLAG_LAYOUT_IN_SCREEN | FLAG_FULLSCREEN | FLAG_LAYOUT_INSET_DECOR)) == (FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR)) {
                 if (DEBUG_LAYOUT)
-                    Log.v(TAG, "layoutWindowLw(" + attrs.getTitle() 
+                    Log.v(TAG, "layoutWindowLw(" + attrs.getTitle()
                             + "): IN_SCREEN, INSET_DECOR, !FULLSCREEN");
                 // This is the case for a normal activity window: we want it
                 // to cover all of the screen space, and it can take care of
@@ -2132,21 +2248,25 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                 } else {
                     if (attrs.type == TYPE_STATUS_BAR_PANEL
                             || attrs.type == TYPE_STATUS_BAR_SUB_PANEL) {
-                        // Status bar panels are the only windows who can go on top of
-                        // the status bar.  They are protected by the STATUS_BAR_SERVICE
-                        // permission, so they have the same privileges as the status
+                        // Status bar panels are the only windows who can go on
+                        // top of
+                        // the status bar. They are protected by the
+                        // STATUS_BAR_SERVICE
+                        // permission, so they have the same privileges as the
+                        // status
                         // bar itself.
                         //
-                        // However, they should still dodge the navigation bar if it exists.
+                        // However, they should still dodge the navigation bar
+                        // if it exists.
 
                         pf.left = df.left = hasNavBar ? mDockLeft : mUnrestrictedScreenLeft;
                         pf.top = df.top = mUnrestrictedScreenTop;
                         pf.right = df.right = hasNavBar
-                                            ? mRestrictedScreenLeft+mRestrictedScreenWidth
-                                            : mUnrestrictedScreenLeft+mUnrestrictedScreenWidth;
+                                            ? mRestrictedScreenLeft + mRestrictedScreenWidth
+                                            : mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
                         pf.bottom = df.bottom = hasNavBar
-                                              ? mRestrictedScreenTop+mRestrictedScreenHeight
-                                              : mUnrestrictedScreenTop+mUnrestrictedScreenHeight;
+                                              ? mRestrictedScreenTop + mRestrictedScreenHeight
+                                              : mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
 
                         if (DEBUG_LAYOUT) {
                             Log.v(TAG, String.format(
@@ -2156,8 +2276,8 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                     } else {
                         pf.left = df.left = mRestrictedScreenLeft;
                         pf.top = df.top = mRestrictedScreenTop;
-                        pf.right = df.right = mRestrictedScreenLeft+mRestrictedScreenWidth;
-                        pf.bottom = df.bottom = mRestrictedScreenTop+mRestrictedScreenHeight;
+                        pf.right = df.right = mRestrictedScreenLeft + mRestrictedScreenWidth;
+                        pf.bottom = df.bottom = mRestrictedScreenTop + mRestrictedScreenHeight;
                     }
                     if (adjust != SOFT_INPUT_ADJUST_RESIZE) {
                         cf.left = mDockLeft;
@@ -2189,11 +2309,11 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                     pf.left = df.left = cf.left = hasNavBar ? mDockLeft : mUnrestrictedScreenLeft;
                     pf.top = df.top = cf.top = mUnrestrictedScreenTop;
                     pf.right = df.right = cf.right = hasNavBar
-                                        ? mRestrictedScreenLeft+mRestrictedScreenWidth
-                                        : mUnrestrictedScreenLeft+mUnrestrictedScreenWidth;
+                                        ? mRestrictedScreenLeft + mRestrictedScreenWidth
+                                        : mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
                     pf.bottom = df.bottom = cf.bottom = hasNavBar
-                                          ? mRestrictedScreenTop+mRestrictedScreenHeight
-                                          : mUnrestrictedScreenTop+mUnrestrictedScreenHeight;
+                                          ? mRestrictedScreenTop + mRestrictedScreenHeight
+                                          : mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
 
                     if (DEBUG_LAYOUT) {
                         Log.v(TAG, String.format(
@@ -2204,8 +2324,8 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                     // The navigation bar has Real Ultimate Power.
                     pf.left = df.left = mUnrestrictedScreenLeft;
                     pf.top = df.top = mUnrestrictedScreenTop;
-                    pf.right = df.right = mUnrestrictedScreenLeft+mUnrestrictedScreenWidth;
-                    pf.bottom = df.bottom = mUnrestrictedScreenTop+mUnrestrictedScreenHeight;
+                    pf.right = df.right = mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
+                    pf.bottom = df.bottom = mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
                     if (DEBUG_LAYOUT) {
                         Log.v(TAG, String.format(
                                     "Laying out navigation bar window: (%d,%d - %d,%d)",
@@ -2216,14 +2336,14 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                     // Fullscreen secure system overlays get what they ask for.
                     pf.left = df.left = mUnrestrictedScreenLeft;
                     pf.top = df.top = mUnrestrictedScreenTop;
-                    pf.right = df.right = mUnrestrictedScreenLeft+mUnrestrictedScreenWidth;
-                    pf.bottom = df.bottom = mUnrestrictedScreenTop+mUnrestrictedScreenHeight;
+                    pf.right = df.right = mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
+                    pf.bottom = df.bottom = mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
                 } else {
                     pf.left = df.left = cf.left = mRestrictedScreenLeft;
                     pf.top = df.top = cf.top = mRestrictedScreenTop;
-                    pf.right = df.right = cf.right = mRestrictedScreenLeft+mRestrictedScreenWidth;
+                    pf.right = df.right = cf.right = mRestrictedScreenLeft + mRestrictedScreenWidth;
                     pf.bottom = df.bottom = cf.bottom
-                            = mRestrictedScreenTop+mRestrictedScreenHeight;
+                            = mRestrictedScreenTop + mRestrictedScreenHeight;
                 }
                 if (adjust != SOFT_INPUT_ADJUST_NOTHING) {
                     vf.left = mCurLeft;
@@ -2245,15 +2365,18 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                 // Otherwise, a normal window must be placed inside the content
                 // of all screen decorations.
                 if (attrs.type == TYPE_STATUS_BAR_PANEL) {
-                    // Status bar panels are the only windows who can go on top of
-                    // the status bar.  They are protected by the STATUS_BAR_SERVICE
-                    // permission, so they have the same privileges as the status
+                    // Status bar panels are the only windows who can go on top
+                    // of
+                    // the status bar. They are protected by the
+                    // STATUS_BAR_SERVICE
+                    // permission, so they have the same privileges as the
+                    // status
                     // bar itself.
                     pf.left = df.left = cf.left = mRestrictedScreenLeft;
                     pf.top = df.top = cf.top = mRestrictedScreenTop;
-                    pf.right = df.right = cf.right = mRestrictedScreenLeft+mRestrictedScreenWidth;
+                    pf.right = df.right = cf.right = mRestrictedScreenLeft + mRestrictedScreenWidth;
                     pf.bottom = df.bottom = cf.bottom
-                            = mRestrictedScreenTop+mRestrictedScreenHeight;
+                            = mRestrictedScreenTop + mRestrictedScreenHeight;
                 } else {
                     pf.left = mContentLeft;
                     pf.top = mContentTop;
@@ -2281,21 +2404,22 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                 }
             }
         }
-        
+
         if ((fl & FLAG_LAYOUT_NO_LIMITS) != 0) {
             df.left = df.top = cf.left = cf.top = vf.left = vf.top = -10000;
             df.right = df.bottom = cf.right = cf.bottom = vf.right = vf.bottom = 10000;
         }
 
-        if (DEBUG_LAYOUT) Log.v(TAG, "Compute frame " + attrs.getTitle()
-                + ": sim=#" + Integer.toHexString(sim)
-                + " attach=" + attached + " type=" + attrs.type 
-                + String.format(" flags=0x%08x", fl)
-                + " pf=" + pf.toShortString() + " df=" + df.toShortString()
-                + " cf=" + cf.toShortString() + " vf=" + vf.toShortString());
-        
+        if (DEBUG_LAYOUT)
+            Log.v(TAG, "Compute frame " + attrs.getTitle()
+                    + ": sim=#" + Integer.toHexString(sim)
+                    + " attach=" + attached + " type=" + attrs.type
+                    + String.format(" flags=0x%08x", fl)
+                    + " pf=" + pf.toShortString() + " df=" + df.toShortString()
+                    + " cf=" + cf.toShortString() + " vf=" + vf.toShortString());
+
         win.computeFrameLw(pf, df, cf, vf);
-        
+
         // Dock windows carve out the bottom of the screen, so normal windows
         // can't appear underneath them.
         if (attrs.type == TYPE_INPUT_METHOD && !win.getGivenInsetsPendingLw()) {
@@ -2309,9 +2433,10 @@ public class PhoneWindowManager implements WindowManagerPolicy {
             if (mCurBottom > top) {
                 mCurBottom = top;
             }
-            if (DEBUG_LAYOUT) Log.v(TAG, "Input method: mDockBottom="
-                    + mDockBottom + " mContentBottom="
-                    + mContentBottom + " mCurBottom=" + mCurBottom);
+            if (DEBUG_LAYOUT)
+                Log.v(TAG, "Input method: mDockBottom="
+                        + mDockBottom + " mContentBottom="
+                        + mContentBottom + " mCurBottom=" + mCurBottom);
         }
     }
 
@@ -2324,7 +2449,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
     public void beginAnimationLw(int displayWidth, int displayHeight) {
         mTopFullscreenOpaqueWindowState = null;
         mForceStatusBar = false;
-        
+
         mHideLockScreen = false;
         mAllowLockscreenWhenOn = false;
         mDismissKeyguard = false;
@@ -2333,8 +2458,9 @@ public class PhoneWindowManager implements WindowManagerPolicy {
     /** {@inheritDoc} */
     public void animatingWindowLw(WindowState win,
                                 WindowManager.LayoutParams attrs) {
-        if (DEBUG_LAYOUT) Slog.i(TAG, "Win " + win + ": isVisibleOrBehindKeyguardLw="
-                + win.isVisibleOrBehindKeyguardLw());
+        if (DEBUG_LAYOUT)
+            Slog.i(TAG, "Win " + win + ": isVisibleOrBehindKeyguardLw="
+                    + win.isVisibleOrBehindKeyguardLw());
         if (mTopFullscreenOpaqueWindowState == null &&
                 win.isVisibleOrBehindKeyguardLw()) {
             if ((attrs.flags & FLAG_FORCE_NOT_FULLSCREEN) != 0) {
@@ -2345,14 +2471,17 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                     && attrs.x == 0 && attrs.y == 0
                     && attrs.width == WindowManager.LayoutParams.MATCH_PARENT
                     && attrs.height == WindowManager.LayoutParams.MATCH_PARENT) {
-                if (DEBUG_LAYOUT) Log.v(TAG, "Fullscreen window: " + win);
+                if (DEBUG_LAYOUT)
+                    Log.v(TAG, "Fullscreen window: " + win);
                 mTopFullscreenOpaqueWindowState = win;
                 if ((attrs.flags & FLAG_SHOW_WHEN_LOCKED) != 0) {
-                    if (localLOGV) Log.v(TAG, "Setting mHideLockScreen to true by win " + win);
+                    if (localLOGV)
+                        Log.v(TAG, "Setting mHideLockScreen to true by win " + win);
                     mHideLockScreen = true;
                 }
                 if ((attrs.flags & FLAG_DISMISS_KEYGUARD) != 0) {
-                    if (localLOGV) Log.v(TAG, "Setting mDismissKeyguard to true by win " + win);
+                    if (localLOGV)
+                        Log.v(TAG, "Setting mDismissKeyguard to true by win " + win);
                     mDismissKeyguard = true;
                 }
                 if ((attrs.flags & FLAG_ALLOW_LOCK_WHILE_SCREEN_ON) != 0) {
@@ -2372,11 +2501,14 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                 : null;
 
         if (mStatusBar != null) {
-            if (DEBUG_LAYOUT) Log.i(TAG, "force=" + mForceStatusBar
-                    + " top=" + mTopFullscreenOpaqueWindowState);
+            if (DEBUG_LAYOUT)
+                Log.i(TAG, "force=" + mForceStatusBar
+                        + " top=" + mTopFullscreenOpaqueWindowState);
             if (mForceStatusBar) {
-                if (DEBUG_LAYOUT) Log.v(TAG, "Showing status bar: forced");
-                if (mStatusBar.showLw(true)) changes |= FINISH_LAYOUT_REDO_LAYOUT;
+                if (DEBUG_LAYOUT)
+                    Log.v(TAG, "Showing status bar: forced");
+                if (mStatusBar.showLw(true))
+                    changes |= FINISH_LAYOUT_REDO_LAYOUT;
             } else if (mTopFullscreenOpaqueWindowState != null) {
                 if (localLOGV) {
                     Log.d(TAG, "frame: " + mTopFullscreenOpaqueWindowState.getFrameLw()
@@ -2385,40 +2517,51 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                             + " lp.flags=0x" + Integer.toHexString(lp.flags));
                 }
                 topIsFullscreen = (lp.flags & WindowManager.LayoutParams.FLAG_FULLSCREEN) != 0;
-                // The subtle difference between the window for mTopFullscreenOpaqueWindowState
-                // and mTopIsFullscreen is that that mTopIsFullscreen is set only if the window
-                // has the FLAG_FULLSCREEN set.  Not sure if there is another way that to be the
+                // The subtle difference between the window for
+                // mTopFullscreenOpaqueWindowState
+                // and mTopIsFullscreen is that that mTopIsFullscreen is set
+                // only if the window
+                // has the FLAG_FULLSCREEN set. Not sure if there is another way
+                // that to be the
                 // case though.
                 if (topIsFullscreen) {
                     if (mStatusBarCanHide) {
-                        if (DEBUG_LAYOUT) Log.v(TAG, "Hiding status bar");
+                        if (DEBUG_LAYOUT)
+                            Log.v(TAG, "Hiding status bar");
                         if (mStatusBar.hideLw(true)) {
                             changes |= FINISH_LAYOUT_REDO_LAYOUT;
 
-                            mHandler.post(new Runnable() { public void run() {
-                                if (mStatusBarService != null) {
-                                    try {
-                                        mStatusBarService.collapse();
-                                    } catch (RemoteException ex) {}
+                            mHandler.post(new Runnable() {
+                                public void run() {
+                                    if (mStatusBarService != null) {
+                                        try {
+                                            mStatusBarService.collapse();
+                                        } catch (RemoteException ex) {
+                                        }
+                                    }
                                 }
-                            }});
+                            });
                         }
                     } else if (DEBUG_LAYOUT) {
                         Log.v(TAG, "Preventing status bar from hiding by policy");
                     }
                 } else {
-                    if (DEBUG_LAYOUT) Log.v(TAG, "Showing status bar: top is not fullscreen");
-                    if (mStatusBar.showLw(true)) changes |= FINISH_LAYOUT_REDO_LAYOUT;
+                    if (DEBUG_LAYOUT)
+                        Log.v(TAG, "Showing status bar: top is not fullscreen");
+                    if (mStatusBar.showLw(true))
+                        changes |= FINISH_LAYOUT_REDO_LAYOUT;
                 }
             }
         }
 
         mTopIsFullscreen = topIsFullscreen;
 
-        // Hide the key guard if a visible window explicitly specifies that it wants to be displayed
+        // Hide the key guard if a visible window explicitly specifies that it
+        // wants to be displayed
         // when the screen is locked
         if (mKeyguard != null) {
-            if (localLOGV) Log.v(TAG, "finishAnimationLw::mHideKeyguard="+mHideLockScreen);
+            if (localLOGV)
+                Log.v(TAG, "finishAnimationLw::mHideKeyguard=" + mHideLockScreen);
             if (mDismissKeyguard && !mKeyguardMediator.isSecure()) {
                 if (mKeyguard.hideLw(true)) {
                     changes |= FINISH_LAYOUT_REDO_LAYOUT
@@ -2449,8 +2592,9 @@ public class PhoneWindowManager implements WindowManagerPolicy {
             }
         }
 
-        if ((updateSystemUiVisibilityLw()&View.SYSTEM_UI_FLAG_HIDE_NAVIGATION) != 0) {
-            // If the navigation bar has been hidden or shown, we need to do another
+        if ((updateSystemUiVisibilityLw() & View.SYSTEM_UI_FLAG_HIDE_NAVIGATION) != 0) {
+            // If the navigation bar has been hidden or shown, we need to do
+            // another
             // layout pass to update that window.
             changes |= FINISH_LAYOUT_REDO_LAYOUT;
         }
@@ -2467,24 +2611,25 @@ public class PhoneWindowManager implements WindowManagerPolicy {
             return false;
         }
         if (false) {
-            // Don't do this on the tablet, since the system bar never completely
+            // Don't do this on the tablet, since the system bar never
+            // completely
             // covers the screen, and with all its transparency this will
-            // incorrectly think it does cover it when it doesn't.  We'll revisit
+            // incorrectly think it does cover it when it doesn't. We'll revisit
             // this later when we re-do the phone status bar.
             if (mStatusBar != null && mStatusBar.isVisibleLw()) {
                 RectF rect = new RectF(mStatusBar.getShownFrameLw());
-                for (int i=mStatusBarPanels.size()-1; i>=0; i--) {
+                for (int i = mStatusBarPanels.size() - 1; i >= 0; i--) {
                     WindowState w = mStatusBarPanels.get(i);
                     if (w.isVisibleLw()) {
                         rect.union(w.getShownFrameLw());
                     }
                 }
-                final int insetw = mRestrictedScreenWidth/10;
-                final int inseth = mRestrictedScreenHeight/10;
-                if (rect.contains(insetw, inseth, mRestrictedScreenWidth-insetw,
-                            mRestrictedScreenHeight-inseth)) {
+                final int insetw = mRestrictedScreenWidth / 10;
+                final int inseth = mRestrictedScreenHeight / 10;
+                if (rect.contains(insetw, inseth, mRestrictedScreenWidth - insetw,
+                            mRestrictedScreenHeight - inseth)) {
                     // All of the status bar windows put together cover the
-                    // screen, so the app can't be seen.  (Note this test doesn't
+                    // screen, so the app can't be seen. (Note this test doesn't
                     // work if the rects of these windows are at off offsets or
                     // sizes, causing gaps in the rect union we have computed.)
                     return false;
@@ -2496,8 +2641,9 @@ public class PhoneWindowManager implements WindowManagerPolicy {
 
     public int focusChangedLw(WindowState lastFocus, WindowState newFocus) {
         mFocusedWindow = newFocus;
-        if ((updateSystemUiVisibilityLw()&View.SYSTEM_UI_FLAG_HIDE_NAVIGATION) != 0) {
-            // If the navigation bar has been hidden or shown, we need to do another
+        if ((updateSystemUiVisibilityLw() & View.SYSTEM_UI_FLAG_HIDE_NAVIGATION) != 0) {
+            // If the navigation bar has been hidden or shown, we need to do
+            // another
             // layout pass to update that window.
             return FINISH_LAYOUT_REDO_LAYOUT;
         }
@@ -2505,6 +2651,23 @@ public class PhoneWindowManager implements WindowManagerPolicy {
     }
 
     /** {@inheritDoc} */
+    public void notifyConvertibleSwitchChanged(long whenNanos, boolean convertibleOpen) {
+        // lid changed state
+        mConvertible = convertibleOpen ? CONVERTIBLE_OPEN : CONVERTIBLE_CLOSED;
+        updateKeyboardVisibility();
+
+        Log.d(TAG, "Update Rotation");
+        updateRotation(true);
+
+        Log.d(TAG, "Light up the keyboard");
+        // Light up the keyboard if we are sliding up.
+
+        mPowerManager.userActivity(SystemClock.uptimeMillis(), false,
+                            LocalPowerManager.BUTTON_EVENT);
+
+    }
+
+    /** {@inheritDoc} */
     public void notifyLidSwitchChanged(long whenNanos, boolean lidOpen) {
         // lid changed state
         mLidOpen = lidOpen ? LID_OPEN : LID_CLOSED;
@@ -2561,7 +2724,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                 char[] buf = new char[15];
                 int n = reader.read(buf);
                 if (n > 1) {
-                    plugged = 0 != Integer.parseInt(new String(buf, 0, n-1));
+                    plugged = 0 != Integer.parseInt(new String(buf, 0, n - 1));
                 }
             } catch (IOException ex) {
                 Slog.w(TAG, "Couldn't read hdmi state from " + filename + ": " + ex);
@@ -2577,7 +2740,8 @@ public class PhoneWindowManager implements WindowManagerPolicy {
             }
         }
         // This dance forces the code in setHdmiPlugged to run.
-        // Always do this so the sticky intent is stuck (to false) if there is no hdmi.
+        // Always do this so the sticky intent is stuck (to false) if there is
+        // no hdmi.
         mHdmiPlugged = !plugged;
         setHdmiPlugged(!mHdmiPlugged);
     }
@@ -2586,7 +2750,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
      * @return Whether music is being played right now.
      */
     boolean isMusicActive() {
-        final AudioManager am = (AudioManager)mContext.getSystemService(Context.AUDIO_SERVICE);
+        final AudioManager am = (AudioManager) mContext.getSystemService(Context.AUDIO_SERVICE);
         if (am == null) {
             Log.w(TAG, "isMusicActive: couldn't get AudioManager reference");
             return false;
@@ -2596,6 +2760,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
 
     /**
      * Tell the audio service to adjust the volume appropriate to the event.
+     * 
      * @param keycode
      */
     void handleVolumeKey(int stream, int keycode) {
@@ -2605,12 +2770,13 @@ public class PhoneWindowManager implements WindowManagerPolicy {
         }
         try {
             // since audio is playing, we shouldn't have to hold a wake lock
-            // during the call, but we do it as a precaution for the rare possibility
+            // during the call, but we do it as a precaution for the rare
+            // possibility
             // that the music stops right before we call this
             // TODO: Actually handle MUTE.
             mBroadcastWakeLock.acquire();
             audioService.adjustStreamVolume(stream,
-                keycode == KeyEvent.KEYCODE_VOLUME_UP
+                    keycode == KeyEvent.KEYCODE_VOLUME_UP
                             ? AudioManager.ADJUST_RAISE
                             : AudioManager.ADJUST_LOWER,
                     0);
@@ -2625,7 +2791,8 @@ public class PhoneWindowManager implements WindowManagerPolicy {
     ServiceConnection mScreenshotConnection = null;
 
     final Runnable mScreenshotTimeout = new Runnable() {
-        @Override public void run() {
+        @Override
+        public void run() {
             synchronized (mScreenshotLock) {
                 if (mScreenshotConnection != null) {
                     mContext.unbindService(mScreenshotConnection);
@@ -2679,8 +2846,10 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                         }
                     }
                 }
+
                 @Override
-                public void onServiceDisconnected(ComponentName name) {}
+                public void onServiceDisconnected(ComponentName name) {
+                }
             };
             if (mContext.bindService(intent, conn, Context.BIND_AUTO_CREATE)) {
                 mScreenshotConnection = conn;
@@ -2698,9 +2867,11 @@ public class PhoneWindowManager implements WindowManagerPolicy {
 
         final boolean isInjected = (policyFlags & WindowManagerPolicy.FLAG_INJECTED) != 0;
 
-        // If screen is off then we treat the case where the keyguard is open but hidden
+        // If screen is off then we treat the case where the keyguard is open
+        // but hidden
         // the same as if it were open and in front.
-        // This will prevent any keys other than the power button from waking the screen
+        // This will prevent any keys other than the power button from waking
+        // the screen
         // when the keyguard is hidden by another activity.
         final boolean keyguardActive = (isScreenOn ?
                                         mKeyguardMediator.isShowingAndNotHidden() :
@@ -2713,7 +2884,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
 
         if (false) {
             Log.d(TAG, "interceptKeyTq keycode=" + keyCode
-                  + " screenIsOn=" + isScreenOn + " keyguardActive=" + keyguardActive);
+                    + " screenIsOn=" + isScreenOn + " keyguardActive=" + keyguardActive);
         }
 
         if (down && (policyFlags & WindowManagerPolicy.FLAG_VIRTUAL) != 0
@@ -2722,19 +2893,25 @@ public class PhoneWindowManager implements WindowManagerPolicy {
         }
 
         // Basic policy based on screen state and keyguard.
-        // FIXME: This policy isn't quite correct.  We shouldn't care whether the screen
-        //        is on or off, really.  We should care about whether the device is in an
-        //        interactive state or is in suspend pretending to be "off".
-        //        The primary screen might be turned off due to proximity sensor or
-        //        because we are presenting media on an auxiliary screen or remotely controlling
-        //        the device some other way (which is why we have an exemption here for injected
-        //        events).
+        // FIXME: This policy isn't quite correct. We shouldn't care whether the
+        // screen
+        // is on or off, really. We should care about whether the device is in
+        // an
+        // interactive state or is in suspend pretending to be "off".
+        // The primary screen might be turned off due to proximity sensor or
+        // because we are presenting media on an auxiliary screen or remotely
+        // controlling
+        // the device some other way (which is why we have an exemption here for
+        // injected
+        // events).
         int result;
         if (isScreenOn || isInjected) {
-            // When the screen is on or if the key is injected pass the key to the application.
+            // When the screen is on or if the key is injected pass the key to
+            // the application.
             result = ACTION_PASS_TO_USER;
         } else {
-            // When the screen is off and the key is not injected, determine whether
+            // When the screen is off and the key is not injected, determine
+            // whether
             // to wake the device but don't pass the key to the application.
             result = 0;
 
@@ -2742,7 +2919,8 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                     & (WindowManagerPolicy.FLAG_WAKE | WindowManagerPolicy.FLAG_WAKE_DROPPED)) != 0;
             if (down && isWakeKey) {
                 if (keyguardActive) {
-                    // If the keyguard is showing, let it decide what to do with the wake key.
+                    // If the keyguard is showing, let it decide what to do with
+                    // the wake key.
                     mKeyguardMediator.onWakeKeyWhenKeyguardShowingTq(keyCode,
                             mDockMode != Intent.EXTRA_DOCK_STATE_UNDOCKED);
                 } else {
@@ -2789,28 +2967,37 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                     if (telephonyService != null) {
                         try {
                             if (telephonyService.isRinging()) {
-                                // If an incoming call is ringing, either VOLUME key means
-                                // "silence ringer".  We handle these keys here, rather than
-                                // in the InCallScreen, to make sure we'll respond to them
-                                // even if the InCallScreen hasn't come to the foreground yet.
-                                // Look for the DOWN event here, to agree with the "fallback"
+                                // If an incoming call is ringing, either VOLUME
+                                // key means
+                                // "silence ringer". We handle these keys here,
+                                // rather than
+                                // in the InCallScreen, to make sure we'll
+                                // respond to them
+                                // even if the InCallScreen hasn't come to the
+                                // foreground yet.
+                                // Look for the DOWN event here, to agree with
+                                // the "fallback"
                                 // behavior in the InCallScreen.
                                 Log.i(TAG, "interceptKeyBeforeQueueing:"
-                                      + " VOLUME key-down while ringing: Silence ringer!");
+                                        + " VOLUME key-down while ringing: Silence ringer!");
 
-                                // Silence the ringer.  (It's safe to call this
-                                // even if the ringer has already been silenced.)
+                                // Silence the ringer. (It's safe to call this
+                                // even if the ringer has already been
+                                // silenced.)
                                 telephonyService.silenceRinger();
 
-                                // And *don't* pass this key thru to the current activity
+                                // And *don't* pass this key thru to the current
+                                // activity
                                 // (which is probably the InCallScreen.)
                                 result &= ~ACTION_PASS_TO_USER;
                                 break;
                             }
                             if (telephonyService.isOffhook()
                                     && (result & ACTION_PASS_TO_USER) == 0) {
-                                // If we are in call but we decided not to pass the key to
-                                // the application, handle the volume change here.
+                                // If we are in call but we decided not to pass
+                                // the key to
+                                // the application, handle the volume change
+                                // here.
                                 handleVolumeKey(AudioManager.STREAM_VOICE_CALL, keyCode);
                                 break;
                             }
@@ -2820,7 +3007,8 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                     }
 
                     if (isMusicActive() && (result & ACTION_PASS_TO_USER) == 0) {
-                        // If music is playing but we decided not to pass the key to the
+                        // If music is playing but we decided not to pass the
+                        // key to the
                         // application, handle the volume change here.
                         handleVolumeKey(AudioManager.STREAM_MUSIC, keyCode);
                         break;
@@ -2844,14 +3032,12 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                     interceptPowerKeyDown(!isScreenOn || hungUp);
                 } else {
                     if (interceptPowerKeyUp(canceled)) {
-                        if ((mEndcallBehavior
-                                & Settings.System.END_BUTTON_BEHAVIOR_HOME) != 0) {
+                        if ((mEndcallBehavior & Settings.System.END_BUTTON_BEHAVIOR_HOME) != 0) {
                             if (goHome()) {
                                 break;
                             }
                         }
-                        if ((mEndcallBehavior
-                                & Settings.System.END_BUTTON_BEHAVIOR_SLEEP) != 0) {
+                        if ((mEndcallBehavior & Settings.System.END_BUTTON_BEHAVIOR_SLEEP) != 0) {
                             result = (result & ~ACTION_POKE_USER_ACTIVITY) | ACTION_GO_TO_SLEEP;
                         }
                     }
@@ -2874,14 +3060,17 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                     if (telephonyService != null) {
                         try {
                             if (telephonyService.isRinging()) {
-                                // Pressing Power while there's a ringing incoming
+                                // Pressing Power while there's a ringing
+                                // incoming
                                 // call should silence the ringer.
                                 telephonyService.silenceRinger();
                             } else if ((mIncallPowerBehavior
                                     & Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR_HANGUP) != 0
                                     && telephonyService.isOffhook()) {
-                                // Otherwise, if "Power button ends call" is enabled,
-                                // the Power button will hang up any current active call.
+                                // Otherwise, if "Power button ends call" is
+                                // enabled,
+                                // the Power button will hang up any current
+                                // active call.
                                 hungUp = telephonyService.endCall();
                             }
                         } catch (RemoteException ex) {
@@ -2909,7 +3098,8 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                     if (telephonyService != null) {
                         try {
                             if (!telephonyService.isIdle()) {
-                                // Suppress PLAY/PAUSE toggle when phone is ringing or in-call
+                                // Suppress PLAY/PAUSE toggle when phone is
+                                // ringing or in-call
                                 // to avoid music playback.
                                 break;
                             }
@@ -2927,9 +3117,12 @@ public class PhoneWindowManager implements WindowManagerPolicy {
             case KeyEvent.KEYCODE_MEDIA_RECORD:
             case KeyEvent.KEYCODE_MEDIA_FAST_FORWARD: {
                 if ((result & ACTION_PASS_TO_USER) == 0) {
-                    // Only do this if we would otherwise not pass it to the user. In that
-                    // case, the PhoneWindow class will do the same thing, except it will
-                    // only do it if the showing app doesn't process the key on its own.
+                    // Only do this if we would otherwise not pass it to the
+                    // user. In that
+                    // case, the PhoneWindow class will do the same thing,
+                    // except it will
+                    // only do it if the showing app doesn't process the key on
+                    // its own.
                     mBroadcastWakeLock.acquire();
                     mHandler.post(new PassHeadsetKey(new KeyEvent(event)));
                 }
@@ -2943,10 +3136,11 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                         try {
                             if (telephonyService.isRinging()) {
                                 Log.i(TAG, "interceptKeyBeforeQueueing:"
-                                      + " CALL key-down while ringing: Answer the call!");
+                                        + " CALL key-down while ringing: Answer the call!");
                                 telephonyService.answerRingingCall();
 
-                                // And *don't* pass this key thru to the current activity
+                                // And *don't* pass this key thru to the current
+                                // activity
                                 // (which is presumably the InCallScreen.)
                                 result &= ~ACTION_PASS_TO_USER;
                             }
@@ -2970,7 +3164,8 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                 & (WindowManagerPolicy.FLAG_WAKE | WindowManagerPolicy.FLAG_WAKE_DROPPED)) != 0;
         if (isWakeMotion) {
             if (mKeyguardMediator.isShowing()) {
-                // If the keyguard is showing, let it decide what to do with the wake motion.
+                // If the keyguard is showing, let it decide what to do with the
+                // wake motion.
                 mKeyguardMediator.onWakeMotionWhenKeyguardShowingTq();
             } else {
                 // Otherwise, wake the device ourselves.
@@ -3045,19 +3240,21 @@ public class PhoneWindowManager implements WindowManagerPolicy {
         }
         if (screenOnListener != null) {
             mKeyguardMediator.onScreenTurnedOn(new KeyguardViewManager.ShowListener() {
-                @Override public void onShown(IBinder windowToken) {
+                @Override
+                public void onShown(IBinder windowToken) {
                     if (windowToken != null) {
                         try {
                             mWindowManager.waitForWindowDrawn(windowToken,
                                     new IRemoteCallback.Stub() {
-                                @Override public void sendResult(Bundle data) {
-                                    Slog.i(TAG, "Lock screen displayed!");
-                                    screenOnListener.onScreenOn();
-                                    synchronized (mLock) {
-                                        mScreenOnFully = true;
-                                    }
-                                }
-                            });
+                                        @Override
+                                        public void sendResult(Bundle data) {
+                                            Slog.i(TAG, "Lock screen displayed!");
+                                            screenOnListener.onScreenOn();
+                                            synchronized (mLock) {
+                                                mScreenOnFully = true;
+                                            }
+                                        }
+                                    });
                         } catch (RemoteException e) {
                         }
                     } else {
@@ -3085,12 +3282,12 @@ public class PhoneWindowManager implements WindowManagerPolicy {
     public boolean isScreenOnEarly() {
         return mScreenOnEarly;
     }
-    
+
     /** {@inheritDoc} */
     public boolean isScreenOnFully() {
         return mScreenOnFully;
     }
-    
+
     /** {@inheritDoc} */
     public void enableKeyguard(boolean enabled) {
         mKeyguardMediator.setKeyguardEnabled(enabled);
@@ -3105,7 +3302,6 @@ public class PhoneWindowManager implements WindowManagerPolicy {
         return mKeyguardMediator.isShowingAndNotHidden();
     }
 
-
     /** {@inheritDoc} */
     public boolean isKeyguardLocked() {
         return keyguardOn();
@@ -3157,20 +3353,27 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                         + orientation + ", last=" + lastRotation
                         + "); user=" + mUserRotation + " "
                         + ((mUserRotationMode == WindowManagerPolicy.USER_ROTATION_LOCKED)
-                            ? "USER_ROTATION_LOCKED" : "")
+                                ? "USER_ROTATION_LOCKED" : "")
                         );
         }
 
         synchronized (mLock) {
-            int sensorRotation = mOrientationListener.getProposedRotation(); // may be -1
+            int sensorRotation = mOrientationListener.getProposedRotation(); // may
+                                                                             // be
+                                                                             // -1
             if (sensorRotation < 0) {
                 sensorRotation = lastRotation;
             }
 
             final int preferredRotation;
-            if (mLidOpen == LID_OPEN && mLidOpenRotation >= 0) {
+            if (mLidOpen == LID_OPEN && mLidInflueceRotation==2 ||
+                mLidOpen == LID_CLOSED && mLidInflueceRotation==1) {
                 // Ignore sensor when lid switch is open and rotation is forced.
                 preferredRotation = mLidOpenRotation;
+            } else if (mConvertible == CONVERTIBLE_OPEN && mConvertibleInflueceRotation == 2 || 
+                       mConvertible ==CONVERTIBLE_CLOSED && mConvertibleInflueceRotation == 1) {
+                    // Ignore sensor when lid switch is open and rotation is forced.
+                    preferredRotation = mConvertibleRotation;
             } else if (mDockMode == Intent.EXTRA_DOCK_STATE_CAR
                     && (mCarDockEnablesAccelerometer || mCarDockRotation >= 0)) {
                 // Ignore sensor when in car dock unless explicitly enabled.
@@ -3189,17 +3392,23 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                         ? sensorRotation : mDeskDockRotation;
             } else if (mHdmiPlugged) {
                 // Ignore sensor when plugged into HDMI.
-                // Note that the dock orientation overrides the HDMI orientation.
+                // Note that the dock orientation overrides the HDMI
+                // orientation.
                 preferredRotation = mHdmiRotation;
-            } else if ((mAccelerometerDefault != 0 /* implies not rotation locked */
-                            && (orientation == ActivityInfo.SCREEN_ORIENTATION_USER
+            } else if ((mAccelerometerDefault != 0 /*
+                                                    * implies not rotation
+                                                    * locked
+                                                    */
+            && (orientation == ActivityInfo.SCREEN_ORIENTATION_USER
                                     || orientation == ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED))
                     || orientation == ActivityInfo.SCREEN_ORIENTATION_SENSOR
                     || orientation == ActivityInfo.SCREEN_ORIENTATION_FULL_SENSOR
                     || orientation == ActivityInfo.SCREEN_ORIENTATION_SENSOR_LANDSCAPE
                     || orientation == ActivityInfo.SCREEN_ORIENTATION_SENSOR_PORTRAIT) {
-                // Otherwise, use sensor only if requested by the application or enabled
-                // by default for USER or UNSPECIFIED modes.  Does not apply to NOSENSOR.
+                // Otherwise, use sensor only if requested by the application or
+                // enabled
+                // by default for USER or UNSPECIFIED modes. Does not apply to
+                // NOSENSOR.
                 if (mAllowAllRotations < 0) {
                     // Can't read this during init() because the context doesn't
                     // have display metrics at that time so we cannot determine
@@ -3274,7 +3483,8 @@ public class PhoneWindowManager implements WindowManagerPolicy {
 
                 default:
                     // For USER, UNSPECIFIED, NOSENSOR, SENSOR and FULL_SENSOR,
-                    // just return the preferred orientation we already calculated.
+                    // just return the preferred orientation we already
+                    // calculated.
                     if (preferredRotation >= 0) {
                         return preferredRotation;
                     }
@@ -3314,13 +3524,15 @@ public class PhoneWindowManager implements WindowManagerPolicy {
         return rotation == mPortraitRotation || rotation == mUpsideDownRotation;
     }
 
-
-    // User rotation: to be used when all else fails in assigning an orientation to the device
+    // User rotation: to be used when all else fails in assigning an orientation
+    // to the device
     public void setUserRotationMode(int mode, int rot) {
         ContentResolver res = mContext.getContentResolver();
 
-        // mUserRotationMode and mUserRotation will be assigned by the content observer
+        // mUserRotationMode and mUserRotation will be assigned by the content
+        // observer
         if (mode == WindowManagerPolicy.USER_ROTATION_LOCKED) {
+            Log.d(TAG,"Rotation locked");
             Settings.System.putInt(res,
                     Settings.System.USER_ROTATION,
                     rot);
@@ -3358,24 +3570,24 @@ public class PhoneWindowManager implements WindowManagerPolicy {
             throw new RuntimeException("window manager dead");
         }
     }
-    
+
     static long[] getLongIntArray(Resources r, int resid) {
         int[] ar = r.getIntArray(resid);
         if (ar == null) {
             return null;
         }
         long[] out = new long[ar.length];
-        for (int i=0; i<ar.length; i++) {
+        for (int i = 0; i < ar.length; i++) {
             out[i] = ar[i];
         }
         return out;
     }
-    
+
     /** {@inheritDoc} */
     public void systemReady() {
         // tell the keyguard
         mKeyguardMediator.onSystemReady();
-        android.os.SystemProperties.set("dev.bootcomplete", "1"); 
+        android.os.SystemProperties.set("dev.bootcomplete", "1");
         synchronized (mLock) {
             updateOrientationListenerLp();
             mSystemReady = true;
@@ -3399,27 +3611,40 @@ public class PhoneWindowManager implements WindowManagerPolicy {
     /** {@inheritDoc} */
     public void showBootMessage(final CharSequence msg, final boolean always) {
         mHandler.post(new Runnable() {
-            @Override public void run() {
+            @Override
+            public void run() {
                 if (mBootMsgDialog == null) {
                     mBootMsgDialog = new ProgressDialog(mContext) {
                         // This dialog will consume all events coming in to
-                        // it, to avoid it trying to do things too early in boot.
-                        @Override public boolean dispatchKeyEvent(KeyEvent event) {
+                        // it, to avoid it trying to do things too early in
+                        // boot.
+                        @Override
+                        public boolean dispatchKeyEvent(KeyEvent event) {
                             return true;
                         }
-                        @Override public boolean dispatchKeyShortcutEvent(KeyEvent event) {
+
+                        @Override
+                        public boolean dispatchKeyShortcutEvent(KeyEvent event) {
                             return true;
                         }
-                        @Override public boolean dispatchTouchEvent(MotionEvent ev) {
+
+                        @Override
+                        public boolean dispatchTouchEvent(MotionEvent ev) {
                             return true;
                         }
-                        @Override public boolean dispatchTrackballEvent(MotionEvent ev) {
+
+                        @Override
+                        public boolean dispatchTrackballEvent(MotionEvent ev) {
                             return true;
                         }
-                        @Override public boolean dispatchGenericMotionEvent(MotionEvent ev) {
+
+                        @Override
+                        public boolean dispatchGenericMotionEvent(MotionEvent ev) {
                             return true;
                         }
-                        @Override public boolean dispatchPopulateAccessibilityEvent(
+
+                        @Override
+                        public boolean dispatchPopulateAccessibilityEvent(
                                 AccessibilityEvent event) {
                             return true;
                         }
@@ -3431,7 +3656,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                             WindowManager.LayoutParams.TYPE_BOOT_PROGRESS);
                     mBootMsgDialog.getWindow().addFlags(
                             WindowManager.LayoutParams.FLAG_DIM_BEHIND
-                            | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN);
+                                    | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN);
                     mBootMsgDialog.getWindow().setDimAmount(1);
                     WindowManager.LayoutParams lp = mBootMsgDialog.getWindow().getAttributes();
                     lp.screenOrientation = ActivityInfo.SCREEN_ORIENTATION_NOSENSOR;
@@ -3447,7 +3672,8 @@ public class PhoneWindowManager implements WindowManagerPolicy {
     /** {@inheritDoc} */
     public void hideBootMessages() {
         mHandler.post(new Runnable() {
-            @Override public void run() {
+            @Override
+            public void run() {
                 if (mBootMsgDialog != null) {
                     mBootMsgDialog.dismiss();
                     mBootMsgDialog = null;
@@ -3481,7 +3707,8 @@ public class PhoneWindowManager implements WindowManagerPolicy {
     Runnable mScreenLockTimeout = new Runnable() {
         public void run() {
             synchronized (this) {
-                if (localLOGV) Log.v(TAG, "mScreenLockTimeout activating keyguard");
+                if (localLOGV)
+                    Log.v(TAG, "mScreenLockTimeout activating keyguard");
                 mKeyguardMediator.doKeyguardTimeout();
                 mLockScreenTimerActive = false;
             }
@@ -3490,13 +3717,16 @@ public class PhoneWindowManager implements WindowManagerPolicy {
 
     private void updateLockScreenTimeout() {
         synchronized (mScreenLockTimeout) {
-            boolean enable = (mAllowLockscreenWhenOn && mScreenOnEarly && mKeyguardMediator.isSecure());
+            boolean enable = (mAllowLockscreenWhenOn && mScreenOnEarly && mKeyguardMediator
+                    .isSecure());
             if (mLockScreenTimerActive != enable) {
                 if (enable) {
-                    if (localLOGV) Log.v(TAG, "setting lockscreen timer");
+                    if (localLOGV)
+                        Log.v(TAG, "setting lockscreen timer");
                     mHandler.postDelayed(mScreenLockTimeout, mLockScreenTimeout);
                 } else {
-                    if (localLOGV) Log.v(TAG, "clearing lockscreen timer");
+                    if (localLOGV)
+                        Log.v(TAG, "clearing lockscreen timer");
                     mHandler.removeCallbacks(mScreenLockTimeout);
                 }
                 mLockScreenTimerActive = enable;
@@ -3507,18 +3737,31 @@ public class PhoneWindowManager implements WindowManagerPolicy {
     /** {@inheritDoc} */
     public void enableScreenAfterBoot() {
         readLidState();
+        readConvertibleState();
         updateKeyboardVisibility();
 
         updateRotation(true);
     }
 
     private void updateKeyboardVisibility() {
-        mPowerManager.setKeyboardVisibility(mLidOpen == LID_OPEN);
+        if (mConvertible != CONVERTIBLE_ABSENT) {
+            Log.v(TAG, "updateKeyboardVisibility - CONVERTIBLE:" + mConvertible);
+            if (mConvertibleKeyboardAccessibility == 1) {
+                mPowerManager.setKeyboardVisibility(mConvertible == CONVERTIBLE_CLOSED);
+            } else if (mConvertibleKeyboardAccessibility == 2) {
+                mPowerManager.setKeyboardVisibility(mConvertible == CONVERTIBLE_OPEN);
+            } else {
+                mPowerManager.setKeyboardVisibility(true);
+            }
+        } else {
+            Log.v(TAG, "CONVERTIBLE ABSENT");
+            mPowerManager.setKeyboardVisibility(mLidOpen == LID_OPEN);
+        }
     }
 
     void updateRotation(boolean alwaysSendConfiguration) {
         try {
-            //set orientation on WindowManager
+            // set orientation on WindowManager
             mWindowManager.updateRotation(alwaysSendConfiguration);
         } catch (RemoteException e) {
             // Ignore
@@ -3526,22 +3769,25 @@ public class PhoneWindowManager implements WindowManagerPolicy {
     }
 
     /**
-     * Return an Intent to launch the currently active dock app as home.  Returns
-     * null if the standard home should be launched, which is the case if any of the following is
-     * true:
+     * Return an Intent to launch the currently active dock app as home. Returns
+     * null if the standard home should be launched, which is the case if any of
+     * the following is true:
      * <ul>
-     *  <li>The device is not in either car mode or desk mode
-     *  <li>The device is in car mode but ENABLE_CAR_DOCK_HOME_CAPTURE is false
-     *  <li>The device is in desk mode but ENABLE_DESK_DOCK_HOME_CAPTURE is false
-     *  <li>The device is in car mode but there's no CAR_DOCK app with METADATA_DOCK_HOME
-     *  <li>The device is in desk mode but there's no DESK_DOCK app with METADATA_DOCK_HOME
+     * <li>The device is not in either car mode or desk mode
+     * <li>The device is in car mode but ENABLE_CAR_DOCK_HOME_CAPTURE is false
+     * <li>The device is in desk mode but ENABLE_DESK_DOCK_HOME_CAPTURE is false
+     * <li>The device is in car mode but there's no CAR_DOCK app with
+     * METADATA_DOCK_HOME
+     * <li>The device is in desk mode but there's no DESK_DOCK app with
+     * METADATA_DOCK_HOME
      * </ul>
+     * 
      * @return
      */
     Intent createHomeDockIntent() {
         Intent intent = null;
-        
-        // What home does is based on the mode, not the dock state.  That
+
+        // What home does is based on the mode, not the dock state. That
         // is, when in car mode you should be taken to car home regardless
         // of whether we are actually in a car dock.
         if (mUiMode == Configuration.UI_MODE_TYPE_CAR) {
@@ -3557,22 +3803,22 @@ public class PhoneWindowManager implements WindowManagerPolicy {
         if (intent == null) {
             return null;
         }
-        
+
         ActivityInfo ai = intent.resolveActivityInfo(
                 mContext.getPackageManager(), PackageManager.GET_META_DATA);
         if (ai == null) {
             return null;
         }
-        
+
         if (ai.metaData != null && ai.metaData.getBoolean(Intent.METADATA_DOCK_HOME)) {
             intent = new Intent(intent);
             intent.setClassName(ai.packageName, ai.name);
             return intent;
         }
-        
+
         return null;
     }
-    
+
     void startDockOrHome() {
         Intent dock = createHomeDockIntent();
         if (dock != null) {
@@ -3584,9 +3830,10 @@ public class PhoneWindowManager implements WindowManagerPolicy {
         }
         mContext.startActivity(mHomeIntent);
     }
-    
+
     /**
      * goes to the home screen
+     * 
      * @return whether it did anything
      */
     boolean goHome() {
@@ -3603,7 +3850,8 @@ public class PhoneWindowManager implements WindowManagerPolicy {
             // at the front, puts the device to sleep.
             try {
                 if (SystemProperties.getInt("persist.sys.uts-test-mode", 0) == 1) {
-                    /// Roll back EndcallBehavior as the cupcake design to pass P1 lab entry.
+                    // / Roll back EndcallBehavior as the cupcake design to pass
+                    // P1 lab entry.
                     Log.d(TAG, "UTS-TEST-MODE");
                 } else {
                     ActivityManagerNative.getDefault().stopAppSwitches();
@@ -3613,7 +3861,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                         int result = ActivityManagerNative.getDefault()
                                 .startActivity(null, dock,
                                         dock.resolveTypeIfNeeded(mContext.getContentResolver()),
-                                        null, 0, null, null, 0, true /* onlyIfNeeded*/, false,
+                                        null, 0, null, null, 0, true /* onlyIfNeeded */, false,
                                         null, null, false);
                         if (result == IActivityManager.START_RETURN_INTENT_TO_CALLER) {
                             return false;
@@ -3623,18 +3871,19 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                 int result = ActivityManagerNative.getDefault()
                         .startActivity(null, mHomeIntent,
                                 mHomeIntent.resolveTypeIfNeeded(mContext.getContentResolver()),
-                                null, 0, null, null, 0, true /* onlyIfNeeded*/, false,
+                                null, 0, null, null, 0, true /* onlyIfNeeded */, false,
                                 null, null, false);
                 if (result == IActivityManager.START_RETURN_INTENT_TO_CALLER) {
                     return false;
                 }
             } catch (RemoteException ex) {
-                // bummer, the activity manager, which is in this process, is dead
+                // bummer, the activity manager, which is in this process, is
+                // dead
             }
         }
         return true;
     }
-    
+
     public void setCurrentOrientationLw(int newOrientation) {
         synchronized (mLock) {
             if (newOrientation != mCurrentAppOrientation) {
@@ -3679,7 +3928,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
         }
         return true;
     }
-    
+
     public void screenOnStartedLw() {
     }
 
@@ -3698,8 +3947,10 @@ public class PhoneWindowManager implements WindowManagerPolicy {
     }
 
     private int updateSystemUiVisibilityLw() {
-        // If there is no window focused, there will be nobody to handle the events
-        // anyway, so just hang on in whatever state we're in until things settle down.
+        // If there is no window focused, there will be nobody to handle the
+        // events
+        // anyway, so just hang on in whatever state we're in until things
+        // settle down.
         if (mFocusedWindow == null) {
             return 0;
         }
@@ -3716,109 +3967,193 @@ public class PhoneWindowManager implements WindowManagerPolicy {
         mLastFocusNeedsMenu = needsMenu;
         mFocusedApp = mFocusedWindow.getAppToken();
         mHandler.post(new Runnable() {
-                public void run() {
-                    if (mStatusBarService == null) {
-                        mStatusBarService = IStatusBarService.Stub.asInterface(
+            public void run() {
+                if (mStatusBarService == null) {
+                    mStatusBarService = IStatusBarService.Stub.asInterface(
                                 ServiceManager.getService("statusbar"));
-                    }
-                    if (mStatusBarService != null) {
-                        try {
-                            mStatusBarService.setSystemUiVisibility(visibility);
-                            mStatusBarService.topAppWindowChanged(needsMenu);
-                        } catch (RemoteException e) {
-                            // not much to be done
-                            mStatusBarService = null;
-                        }
+                }
+                if (mStatusBarService != null) {
+                    try {
+                        mStatusBarService.setSystemUiVisibility(visibility);
+                        mStatusBarService.topAppWindowChanged(needsMenu);
+                    } catch (RemoteException e) {
+                        // not much to be done
+                        mStatusBarService = null;
                     }
                 }
-            });
+            }
+        });
         return diff;
     }
 
-    // Use this instead of checking config_showNavigationBar so that it can be consistently
+    // Use this instead of checking config_showNavigationBar so that it can be
+    // consistently
     // overridden by qemu.hw.mainkeys in the emulator.
     public boolean hasNavigationBar() {
         return mHasNavigationBar;
     }
 
     public void dump(String prefix, FileDescriptor fd, PrintWriter pw, String[] args) {
-        pw.print(prefix); pw.print("mSafeMode="); pw.print(mSafeMode);
-                pw.print(" mSystemReady="); pw.print(mSystemReady);
-                pw.print(" mSystemBooted="); pw.println(mSystemBooted);
-        pw.print(prefix); pw.print("mLidOpen="); pw.print(mLidOpen);
-                pw.print(" mLidOpenRotation="); pw.print(mLidOpenRotation);
-                pw.print(" mHdmiPlugged="); pw.println(mHdmiPlugged);
+        pw.print(prefix);
+        pw.print("mSafeMode=");
+        pw.print(mSafeMode);
+        pw.print(" mSystemReady=");
+        pw.print(mSystemReady);
+        pw.print(" mSystemBooted=");
+        pw.println(mSystemBooted);
+        pw.print(prefix);
+        pw.print("mLidOpen=");
+        pw.print(mLidOpen);
+        pw.print(" mLidOpenRotation=");
+        pw.print(mLidOpenRotation);
+        pw.print(" mHdmiPlugged=");
+        pw.println(mHdmiPlugged);
         if (mLastSystemUiFlags != 0 || mResettingSystemUiFlags != 0
                 || mForceClearedSystemUiFlags != 0) {
-            pw.print(prefix); pw.print("mLastSystemUiFlags=0x");
-                    pw.print(Integer.toHexString(mLastSystemUiFlags));
-                    pw.print(" mResettingSystemUiFlags=0x");
-                    pw.print(Integer.toHexString(mResettingSystemUiFlags));
-                    pw.print(" mForceClearedSystemUiFlags=0x");
-                    pw.println(Integer.toHexString(mForceClearedSystemUiFlags));
+            pw.print(prefix);
+            pw.print("mLastSystemUiFlags=0x");
+            pw.print(Integer.toHexString(mLastSystemUiFlags));
+            pw.print(" mResettingSystemUiFlags=0x");
+            pw.print(Integer.toHexString(mResettingSystemUiFlags));
+            pw.print(" mForceClearedSystemUiFlags=0x");
+            pw.println(Integer.toHexString(mForceClearedSystemUiFlags));
         }
         if (mLastFocusNeedsMenu) {
-            pw.print(prefix); pw.print("mLastFocusNeedsMenu=");
-                    pw.println(mLastFocusNeedsMenu);
-        }
-        pw.print(prefix); pw.print("mUiMode="); pw.print(mUiMode);
-                pw.print(" mDockMode="); pw.print(mDockMode);
-                pw.print(" mCarDockRotation="); pw.print(mCarDockRotation);
-                pw.print(" mDeskDockRotation="); pw.println(mDeskDockRotation);
-        pw.print(prefix); pw.print("mUserRotationMode="); pw.print(mUserRotationMode);
-                pw.print(" mUserRotation="); pw.print(mUserRotation);
-                pw.print(" mAllowAllRotations="); pw.println(mAllowAllRotations);
-        pw.print(prefix); pw.print("mAccelerometerDefault="); pw.print(mAccelerometerDefault);
-                pw.print(" mCurrentAppOrientation="); pw.println(mCurrentAppOrientation);
-        pw.print(prefix); pw.print("mCarDockEnablesAccelerometer=");
-                pw.print(mCarDockEnablesAccelerometer);
-                pw.print(" mDeskDockEnablesAccelerometer=");
-                pw.println(mDeskDockEnablesAccelerometer);
-        pw.print(prefix); pw.print("mLidKeyboardAccessibility=");
-                pw.print(mLidKeyboardAccessibility);
-                pw.print(" mLidNavigationAccessibility="); pw.print(mLidNavigationAccessibility);
-                pw.print(" mLongPressOnPowerBehavior="); pw.println(mLongPressOnPowerBehavior);
-        pw.print(prefix); pw.print("mScreenOnEarly="); pw.print(mScreenOnEarly);
-                pw.print(" mScreenOnFully="); pw.print(mScreenOnFully);
-                pw.print(" mOrientationSensorEnabled="); pw.print(mOrientationSensorEnabled);
-                pw.print(" mHasSoftInput="); pw.println(mHasSoftInput);
-        pw.print(prefix); pw.print("mUnrestrictedScreen=("); pw.print(mUnrestrictedScreenLeft);
-                pw.print(","); pw.print(mUnrestrictedScreenTop);
-                pw.print(") "); pw.print(mUnrestrictedScreenWidth);
-                pw.print("x"); pw.println(mUnrestrictedScreenHeight);
-        pw.print(prefix); pw.print("mRestrictedScreen=("); pw.print(mRestrictedScreenLeft);
-                pw.print(","); pw.print(mRestrictedScreenTop);
-                pw.print(") "); pw.print(mRestrictedScreenWidth);
-                pw.print("x"); pw.println(mRestrictedScreenHeight);
-        pw.print(prefix); pw.print("mCur=("); pw.print(mCurLeft);
-                pw.print(","); pw.print(mCurTop);
-                pw.print(")-("); pw.print(mCurRight);
-                pw.print(","); pw.print(mCurBottom); pw.println(")");
-        pw.print(prefix); pw.print("mContent=("); pw.print(mContentLeft);
-                pw.print(","); pw.print(mContentTop);
-                pw.print(")-("); pw.print(mContentRight);
-                pw.print(","); pw.print(mContentBottom); pw.println(")");
-        pw.print(prefix); pw.print("mDock=("); pw.print(mDockLeft);
-                pw.print(","); pw.print(mDockTop);
-                pw.print(")-("); pw.print(mDockRight);
-                pw.print(","); pw.print(mDockBottom); pw.println(")");
-        pw.print(prefix); pw.print("mDockLayer="); pw.println(mDockLayer);
-        pw.print(prefix); pw.print("mTopFullscreenOpaqueWindowState=");
-                pw.println(mTopFullscreenOpaqueWindowState);
-        pw.print(prefix); pw.print("mTopIsFullscreen="); pw.print(mTopIsFullscreen);
-                pw.print(" mForceStatusBar="); pw.print(mForceStatusBar);
-                pw.print(" mHideLockScreen="); pw.println(mHideLockScreen);
-        pw.print(prefix); pw.print("mDismissKeyguard="); pw.print(mDismissKeyguard);
-                pw.print(" mHomePressed="); pw.println(mHomePressed);
-        pw.print(prefix); pw.print("mAllowLockscreenWhenOn="); pw.print(mAllowLockscreenWhenOn);
-                pw.print(" mLockScreenTimeout="); pw.print(mLockScreenTimeout);
-                pw.print(" mLockScreenTimerActive="); pw.println(mLockScreenTimerActive);
-        pw.print(prefix); pw.print("mEndcallBehavior="); pw.print(mEndcallBehavior);
-                pw.print(" mIncallPowerBehavior="); pw.print(mIncallPowerBehavior);
-                pw.print(" mLongPressOnHomeBehavior="); pw.println(mLongPressOnHomeBehavior);
-        pw.print(prefix); pw.print("mLandscapeRotation="); pw.print(mLandscapeRotation);
-                pw.print(" mSeascapeRotation="); pw.println(mSeascapeRotation);
-        pw.print(prefix); pw.print("mPortraitRotation="); pw.print(mPortraitRotation);
-                pw.print(" mUpsideDownRotation="); pw.println(mUpsideDownRotation);
+            pw.print(prefix);
+            pw.print("mLastFocusNeedsMenu=");
+            pw.println(mLastFocusNeedsMenu);
+        }
+        pw.print(prefix);
+        pw.print("mUiMode=");
+        pw.print(mUiMode);
+        pw.print(" mDockMode=");
+        pw.print(mDockMode);
+        pw.print(" mCarDockRotation=");
+        pw.print(mCarDockRotation);
+        pw.print(" mDeskDockRotation=");
+        pw.println(mDeskDockRotation);
+        pw.print(prefix);
+        pw.print("mUserRotationMode=");
+        pw.print(mUserRotationMode);
+        pw.print(" mUserRotation=");
+        pw.print(mUserRotation);
+        pw.print(" mAllowAllRotations=");
+        pw.println(mAllowAllRotations);
+        pw.print(prefix);
+        pw.print("mAccelerometerDefault=");
+        pw.print(mAccelerometerDefault);
+        pw.print(" mCurrentAppOrientation=");
+        pw.println(mCurrentAppOrientation);
+        pw.print(prefix);
+        pw.print("mCarDockEnablesAccelerometer=");
+        pw.print(mCarDockEnablesAccelerometer);
+        pw.print(" mDeskDockEnablesAccelerometer=");
+        pw.println(mDeskDockEnablesAccelerometer);
+        pw.print(prefix);
+        pw.print("mLidKeyboardAccessibility=");
+        pw.print(mLidKeyboardAccessibility);
+        pw.print(" mLidNavigationAccessibility=");
+        pw.print(mLidNavigationAccessibility);
+        pw.print(" mLongPressOnPowerBehavior=");
+        pw.println(mLongPressOnPowerBehavior);
+        pw.print(prefix);
+        pw.print("mScreenOnEarly=");
+        pw.print(mScreenOnEarly);
+        pw.print(" mScreenOnFully=");
+        pw.print(mScreenOnFully);
+        pw.print(" mOrientationSensorEnabled=");
+        pw.print(mOrientationSensorEnabled);
+        pw.print(" mHasSoftInput=");
+        pw.println(mHasSoftInput);
+        pw.print(prefix);
+        pw.print("mUnrestrictedScreen=(");
+        pw.print(mUnrestrictedScreenLeft);
+        pw.print(",");
+        pw.print(mUnrestrictedScreenTop);
+        pw.print(") ");
+        pw.print(mUnrestrictedScreenWidth);
+        pw.print("x");
+        pw.println(mUnrestrictedScreenHeight);
+        pw.print(prefix);
+        pw.print("mRestrictedScreen=(");
+        pw.print(mRestrictedScreenLeft);
+        pw.print(",");
+        pw.print(mRestrictedScreenTop);
+        pw.print(") ");
+        pw.print(mRestrictedScreenWidth);
+        pw.print("x");
+        pw.println(mRestrictedScreenHeight);
+        pw.print(prefix);
+        pw.print("mCur=(");
+        pw.print(mCurLeft);
+        pw.print(",");
+        pw.print(mCurTop);
+        pw.print(")-(");
+        pw.print(mCurRight);
+        pw.print(",");
+        pw.print(mCurBottom);
+        pw.println(")");
+        pw.print(prefix);
+        pw.print("mContent=(");
+        pw.print(mContentLeft);
+        pw.print(",");
+        pw.print(mContentTop);
+        pw.print(")-(");
+        pw.print(mContentRight);
+        pw.print(",");
+        pw.print(mContentBottom);
+        pw.println(")");
+        pw.print(prefix);
+        pw.print("mDock=(");
+        pw.print(mDockLeft);
+        pw.print(",");
+        pw.print(mDockTop);
+        pw.print(")-(");
+        pw.print(mDockRight);
+        pw.print(",");
+        pw.print(mDockBottom);
+        pw.println(")");
+        pw.print(prefix);
+        pw.print("mDockLayer=");
+        pw.println(mDockLayer);
+        pw.print(prefix);
+        pw.print("mTopFullscreenOpaqueWindowState=");
+        pw.println(mTopFullscreenOpaqueWindowState);
+        pw.print(prefix);
+        pw.print("mTopIsFullscreen=");
+        pw.print(mTopIsFullscreen);
+        pw.print(" mForceStatusBar=");
+        pw.print(mForceStatusBar);
+        pw.print(" mHideLockScreen=");
+        pw.println(mHideLockScreen);
+        pw.print(prefix);
+        pw.print("mDismissKeyguard=");
+        pw.print(mDismissKeyguard);
+        pw.print(" mHomePressed=");
+        pw.println(mHomePressed);
+        pw.print(prefix);
+        pw.print("mAllowLockscreenWhenOn=");
+        pw.print(mAllowLockscreenWhenOn);
+        pw.print(" mLockScreenTimeout=");
+        pw.print(mLockScreenTimeout);
+        pw.print(" mLockScreenTimerActive=");
+        pw.println(mLockScreenTimerActive);
+        pw.print(prefix);
+        pw.print("mEndcallBehavior=");
+        pw.print(mEndcallBehavior);
+        pw.print(" mIncallPowerBehavior=");
+        pw.print(mIncallPowerBehavior);
+        pw.print(" mLongPressOnHomeBehavior=");
+        pw.println(mLongPressOnHomeBehavior);
+        pw.print(prefix);
+        pw.print("mLandscapeRotation=");
+        pw.print(mLandscapeRotation);
+        pw.print(" mSeascapeRotation=");
+        pw.println(mSeascapeRotation);
+        pw.print(prefix);
+        pw.print("mPortraitRotation=");
+        pw.print(mPortraitRotation);
+        pw.print(" mUpsideDownRotation=");
+        pw.println(mUpsideDownRotation);
     }
 }
diff --git a/services/java/com/android/server/wm/InputManager.java b/services/java/com/android/server/wm/InputManager.java
index a4f0a0c..7681b9a 100644
--- a/services/java/com/android/server/wm/InputManager.java
+++ b/services/java/com/android/server/wm/InputManager.java
@@ -539,6 +539,11 @@ public class InputManager implements Watchdog.Monitor {
         }
         
         @SuppressWarnings("unused")
+        public void notifyConvertibleSwitchChanged(long whenNanos, boolean lidOpen) {
+            mWindowManagerService.mInputMonitor.notifyConvertibleSwitchChanged(whenNanos, lidOpen);
+        }
+        
+        @SuppressWarnings("unused")
         public void notifyInputChannelBroken(InputWindowHandle inputWindowHandle) {
             mWindowManagerService.mInputMonitor.notifyInputChannelBroken(inputWindowHandle);
         }
diff --git a/services/java/com/android/server/wm/InputMonitor.java b/services/java/com/android/server/wm/InputMonitor.java
index fb74d27..edc7bc3 100644
--- a/services/java/com/android/server/wm/InputMonitor.java
+++ b/services/java/com/android/server/wm/InputMonitor.java
@@ -272,6 +272,11 @@ final class InputMonitor {
         mService.mPolicy.notifyLidSwitchChanged(whenNanos, lidOpen);
     }
     
+    /* Notifies that the lid switch changed state. */
+    public void notifyConvertibleSwitchChanged(long whenNanos, boolean lidOpen) {
+        mService.mPolicy.notifyConvertibleSwitchChanged(whenNanos, lidOpen);
+    }
+    
     /* Provides an opportunity for the window manager policy to intercept early key
      * processing as soon as the key has been read from the device. */
     public int interceptKeyBeforeQueueing(
diff --git a/services/jni/com_android_server_InputManager.cpp b/services/jni/com_android_server_InputManager.cpp
index f259883..ffa40c5 100644
--- a/services/jni/com_android_server_InputManager.cpp
+++ b/services/jni/com_android_server_InputManager.cpp
@@ -59,6 +59,7 @@ static const float POINTER_SPEED_EXPONENT = 1.0f / 4;
 static struct {
     jmethodID notifyConfigurationChanged;
     jmethodID notifyLidSwitchChanged;
+    jmethodID notifyConvertibleSwitchChanged;
     jmethodID notifyInputChannelBroken;
     jmethodID notifyANR;
     jmethodID filterInputEvent;
@@ -501,10 +502,10 @@ void NativeInputManager::ensureSpriteControllerLocked() {
 
 void NativeInputManager::notifySwitch(nsecs_t when, int32_t switchCode,
         int32_t switchValue, uint32_t policyFlags) {
-#if DEBUG_INPUT_DISPATCHER_POLICY
+//#if DEBUG_INPUT_DISPATCHER_POLICY
     LOGD("notifySwitch - when=%lld, switchCode=%d, switchValue=%d, policyFlags=0x%x",
             when, switchCode, switchValue, policyFlags);
-#endif
+//#endif
 
     JNIEnv* env = jniEnv();
 
@@ -514,6 +515,11 @@ void NativeInputManager::notifySwitch(nsecs_t when, int32_t switchCode,
                 when, switchValue == 0);
         checkAndClearExceptionFromCallback(env, "notifyLidSwitchChanged");
         break;
+    case SW_TABLET_MODE:
+        env->CallVoidMethod(mCallbacksObj, gCallbacksClassInfo.notifyConvertibleSwitchChanged,
+                when, switchValue == 0);
+        checkAndClearExceptionFromCallback(env, "notifyConvertibleSwitchChanged");
+        break;
     }
 }
 
@@ -1427,6 +1433,9 @@ int register_android_server_InputManager(JNIEnv* env) {
 
     GET_METHOD_ID(gCallbacksClassInfo.notifyLidSwitchChanged, clazz,
             "notifyLidSwitchChanged", "(JZ)V");
+            
+    GET_METHOD_ID(gCallbacksClassInfo.notifyConvertibleSwitchChanged, clazz,
+            "notifyConvertibleSwitchChanged", "(JZ)V");
 
     GET_METHOD_ID(gCallbacksClassInfo.notifyInputChannelBroken, clazz,
             "notifyInputChannelBroken", "(Lcom/android/server/wm/InputWindowHandle;)V");
